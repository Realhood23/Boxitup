{% extends "base.html" %}

{% block title %}{{ project.name }} - Project Editor{% endblock %}

{% block extra_head %}
<!-- Three.js for 3D preview -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="{{ url_for('static', filename='js/three-preview.js') }}"></script>
{% endblock %}

{% block extra_css %}
<style>
    .editor-layout {
        display: grid;
        grid-template-columns: 320px 1fr 320px;
        gap: 1rem;
        height: calc(100vh - 120px);
        padding: 1rem;
    }

    .editor-panel {
        background: var(--bg-card);
        border: 1px solid var(--border);
        border-radius: 0.5rem;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }

    .panel-header {
        padding: 0.75rem 1rem;
        background: var(--bg);
        border-bottom: 1px solid var(--border);
        font-weight: 600;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .panel-content {
        flex: 1;
        overflow-y: auto;
        padding: 1rem;
    }

    .panel-tabs {
        display: flex;
        border-bottom: 1px solid var(--border);
    }

    .panel-tab {
        flex: 1;
        padding: 0.5rem;
        text-align: center;
        cursor: pointer;
        border-bottom: 2px solid transparent;
        font-size: 0.875rem;
    }

    .panel-tab.active {
        border-bottom-color: var(--primary);
        color: var(--primary);
        font-weight: 500;
    }

    /* Canvas area */
    .canvas-container {
        background: #1a1a2e;
        border-radius: 0.5rem;
        position: relative;
        overflow: hidden;
    }

    .canvas-toolbar {
        position: absolute;
        top: 0.75rem;
        left: 0.75rem;
        display: flex;
        gap: 0.5rem;
        z-index: 10;
    }

    .canvas-zoom-controls {
        position: absolute;
        top: 0.75rem;
        right: 0.75rem;
        display: flex;
        gap: 0.25rem;
        z-index: 10;
    }

    .canvas-info {
        position: absolute;
        bottom: 0.75rem;
        left: 0.75rem;
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 0.5rem 0.75rem;
        border-radius: 0.25rem;
        font-size: 0.75rem;
        font-family: monospace;
    }

    .canvas-coords {
        position: absolute;
        bottom: 0.75rem;
        right: 0.75rem;
        background: rgba(0,0,0,0.7);
        color: #4a9eff;
        padding: 0.5rem 0.75rem;
        border-radius: 0.25rem;
        font-size: 0.75rem;
        font-family: monospace;
    }

    #enclosure-canvas {
        width: 100%;
        height: 100%;
        cursor: grab;
    }

    #enclosure-canvas.dragging {
        cursor: grabbing;
    }

    #enclosure-canvas.drag-component {
        cursor: move;
    }

    /* Component list items */
    .component-list-item {
        border: 1px solid var(--border);
        border-radius: 0.375rem;
        padding: 0.75rem;
        margin-bottom: 0.5rem;
        cursor: pointer;
        transition: all 0.2s;
    }

    .component-list-item:hover {
        border-color: var(--primary);
    }

    .component-list-item.selected {
        border-color: var(--primary);
        background: rgba(99, 102, 241, 0.15);
    }

    .component-list-item h4 {
        font-size: 0.875rem;
        margin-bottom: 0.25rem;
    }

    .component-list-item .dims {
        font-size: 0.75rem;
        color: var(--text-muted);
    }

    /* Feature toggles - enhanced styling */
    .feature-item {
        border: 1px solid var(--border);
        border-radius: 0.5rem;
        margin-bottom: 0.75rem;
        overflow: hidden;
        transition: all 0.2s;
    }

    .feature-item.needs-placement {
        border-color: #ef4444;
        border-left: 3px solid #ef4444;
    }

    .feature-item.placed {
        border-color: #10b981;
        border-left: 3px solid #10b981;
    }

    .feature-item.disabled {
        opacity: 0.6;
        border-color: var(--border);
        border-left: 3px solid var(--border);
    }

    .feature-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0.5rem 0.75rem;
        background: var(--bg);
        cursor: pointer;
    }

    .feature-header:hover {
        background: var(--bg-elevated);
    }

    .feature-status-indicator {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-right: 0.5rem;
    }

    .feature-status-indicator.placed {
        background: #10b981;
    }

    .feature-status-indicator.needs-placement {
        background: #ef4444;
    }

    .feature-status-indicator.disabled {
        background: #64748b;
    }

    .feature-body {
        padding: 0.75rem;
        border-top: 1px solid var(--border);
        background: var(--bg-card);
    }

    .feature-name-input {
        width: 100%;
        padding: 0.375rem 0.5rem;
        font-size: 0.8rem;
        border: 1px solid var(--border);
        border-radius: 0.25rem;
        background: var(--bg);
        color: var(--text);
        margin-bottom: 0.5rem;
    }

    .feature-name-input:focus {
        outline: none;
        border-color: var(--primary);
    }

    .feature-info {
        font-size: 0.7rem;
        color: var(--text-muted);
        margin-bottom: 0.5rem;
    }

    .feature-actions {
        display: flex;
        gap: 0.5rem;
    }

    .status-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        padding: 0.125rem 0.5rem;
        border-radius: 9999px;
        font-size: 0.65rem;
        font-weight: 500;
    }

    .status-badge.placed {
        background: rgba(16, 185, 129, 0.2);
        color: #6ee7b7;
    }

    .status-badge.needs-placement {
        background: rgba(239, 68, 68, 0.2);
        color: #fca5a5;
    }

    .status-badge.disabled {
        background: rgba(100, 116, 139, 0.2);
        color: #94a3b8;
    }

    /* Add custom feature button */
    .add-feature-btn {
        width: 100%;
        padding: 0.75rem;
        border: 2px dashed var(--border);
        border-radius: 0.5rem;
        background: transparent;
        color: var(--text-muted);
        cursor: pointer;
        transition: all 0.2s;
        font-size: 0.875rem;
    }

    .add-feature-btn:hover {
        border-color: var(--primary);
        color: var(--primary);
        background: rgba(99, 102, 241, 0.1);
    }

    /* Legacy toggle styling kept for compatibility */
    .feature-toggle {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0.5rem 0.75rem;
        border: 1px solid var(--border);
        border-radius: 0.375rem;
        margin-bottom: 0.5rem;
        font-size: 0.875rem;
    }

    .feature-toggle.enabled {
        border-color: var(--primary);
        background: rgba(99, 102, 241, 0.15);
    }

    .feature-toggle.placed {
        border-color: var(--success);
        background: rgba(16, 185, 129, 0.15);
    }

    .feature-toggle .status-icon {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.75rem;
    }

    .status-pending {
        background: var(--warning);
        color: white;
    }

    .status-placed {
        background: var(--success);
        color: white;
    }

    /* Validation banner */
    .validation-banner {
        padding: 0.75rem 1rem;
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 0.875rem;
    }

    .validation-banner.warning {
        background: rgba(245, 158, 11, 0.15);
        border-bottom: 1px solid rgba(245, 158, 11, 0.3);
        color: #fcd34d;
    }

    .validation-banner.success {
        background: rgba(16, 185, 129, 0.15);
        border-bottom: 1px solid rgba(16, 185, 129, 0.3);
        color: #6ee7b7;
    }

    /* Face selector dropdown in toolbar */
    .face-dropdown {
        background: var(--bg-elevated);
        border: 1px solid var(--border);
        border-radius: 0.25rem;
        color: var(--text);
        padding: 0.25rem 0.5rem;
        font-size: 0.75rem;
        cursor: pointer;
    }

    .face-dropdown:focus {
        outline: none;
        border-color: var(--primary);
    }

    /* Inline hole form styles */
    .inline-hole-form {
        background: var(--bg);
        border: 1px solid var(--border);
        border-radius: 0.5rem;
        padding: 1rem;
        margin-bottom: 1rem;
    }

    .inline-hole-form h4 {
        font-size: 0.875rem;
        margin-bottom: 0.75rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .inline-hole-form .form-row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.5rem;
        margin-bottom: 0.5rem;
    }

    .inline-hole-form .form-group {
        margin-bottom: 0.5rem;
    }

    .inline-hole-form .form-label {
        font-size: 0.7rem;
        color: var(--text-muted);
        margin-bottom: 0.125rem;
    }

    .inline-hole-form .form-input,
    .inline-hole-form .form-select {
        padding: 0.375rem 0.5rem;
        font-size: 0.8rem;
    }

    /* Placement mode indicator */
    .placement-mode-active {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(99, 102, 241, 0.9);
        color: white;
        padding: 0.75rem 1.5rem;
        border-radius: 0.5rem;
        font-size: 0.875rem;
        pointer-events: none;
        z-index: 20;
    }

    /* Selected hole highlight */
    .hole-list-item {
        border: 1px solid var(--border);
        border-radius: 0.375rem;
        padding: 0.5rem 0.75rem;
        margin-bottom: 0.5rem;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 0.875rem;
    }

    .hole-list-item:hover {
        border-color: var(--primary);
    }

    .hole-list-item.selected {
        border-color: #ff6464;
        background: rgba(255, 100, 100, 0.15);
    }

    #enclosure-canvas.placement-mode {
        cursor: crosshair;
    }

    /* Enclosure config */
    .config-section {
        margin-bottom: 1rem;
    }

    .config-section h4 {
        font-size: 0.875rem;
        margin-bottom: 0.5rem;
        color: var(--text-muted);
    }

    .config-row {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 0.5rem;
    }

    .config-row label {
        flex: 1;
        font-size: 0.75rem;
    }

    .config-row input,
    .config-row select {
        width: 80px;
        padding: 0.25rem 0.5rem;
        font-size: 0.75rem;
        border: 1px solid var(--border);
        border-radius: 0.25rem;
    }

    /* Face selector */
    .face-selector {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 0.25rem;
        margin-top: 0.5rem;
    }

    .face-btn {
        padding: 0.5rem;
        text-align: center;
        border: 1px solid var(--border);
        border-radius: 0.25rem;
        cursor: pointer;
        font-size: 0.75rem;
        transition: all 0.2s;
    }

    .face-btn:hover {
        border-color: var(--primary);
    }

    .face-btn.selected {
        background: var(--primary);
        color: white;
        border-color: var(--primary);
    }
</style>
{% endblock %}

{% block content %}
<div x-data="projectEditor()" x-init="init()">
    <!-- Validation Banner -->
    <div class="validation-banner" :class="unplacedCount > 0 ? 'warning' : 'success'">
        <div>
            <template x-if="unplacedCount > 0">
                <span>
                    <strong x-text="unplacedCount"></strong> feature(s) still need holes placed before you can generate
                </span>
            </template>
            <template x-if="unplacedCount === 0 && projectComponents.length > 0">
                <span style="color: #166534;">
                    All holes placed! Ready to generate OpenSCAD script.
                </span>
            </template>
            <template x-if="projectComponents.length === 0">
                <span>Add components to start designing your enclosure</span>
            </template>
        </div>
        <div class="flex gap-2">
            <button class="btn btn-outline btn-sm" @click="autoSuggestHoles()" :disabled="unplacedCount === 0">
                Auto-Suggest Holes
            </button>
            <a href="{{ url_for('generator.preview', project_id=project.id) }}"
               class="btn btn-primary btn-sm"
               :class="{ 'disabled': unplacedCount > 0 || projectComponents.length === 0 }">
                Generate OpenSCAD
            </a>
        </div>
    </div>

    <div class="editor-layout">
        <!-- Left Panel: Components -->
        <div class="editor-panel">
            <div class="panel-tabs">
                <div class="panel-tab" :class="{ active: leftTab === 'project' }" @click="leftTab = 'project'">
                    Project Components
                </div>
                <div class="panel-tab" :class="{ active: leftTab === 'library' }" @click="leftTab = 'library'">
                    Add from Library
                </div>
            </div>

            <div class="panel-content">
                <!-- Project Components Tab -->
                <div x-show="leftTab === 'project'">
                    <template x-if="projectComponents.length === 0">
                        <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
                            <p>No components added yet.</p>
                            <p style="font-size: 0.75rem; margin-top: 0.5rem;">
                                Switch to "Add from Library" to add components.
                            </p>
                        </div>
                    </template>

                    <template x-for="comp in projectComponents" :key="comp.id">
                        <div class="component-list-item"
                             :class="{ selected: selectedComponent?.id === comp.id }"
                             @click="selectComponent(comp)">
                            <div class="flex justify-between items-center">
                                <h4 x-text="comp.component_name"></h4>
                                <div class="flex items-center gap-1">
                                    <label class="flex items-center gap-1" @click.stop title="Lock position">
                                        <input type="checkbox"
                                               :checked="comp.locked"
                                               @change="toggleComponentLock(comp, $event.target.checked)"
                                               style="width: 14px; height: 14px;">
                                        <span style="font-size: 0.7rem; color: var(--text-muted);">ðŸ”’</span>
                                    </label>
                                    <button class="btn btn-sm btn-danger" @click.stop="removeComponent(comp.id)">
                                        &times;
                                    </button>
                                </div>
                            </div>
                            <div class="dims">
                                Position: (<span x-text="comp.position.x_mm"></span>,
                                <span x-text="comp.position.y_mm"></span>,
                                <span x-text="comp.position.z_mm || 0"></span>) mm
                                <span x-show="comp.locked" style="color: var(--warning); margin-left: 0.25rem;">locked</span>
                            </div>
                            <div style="margin-top: 0.5rem;">
                                <template x-for="feat in comp.enabled_features.filter(f => f.enabled)" :key="feat.feature_id">
                                    <span class="badge" :class="feat.hole_placed ? 'badge-success' : 'badge-warning'"
                                          style="margin-right: 0.25rem; font-size: 0.65rem;">
                                        <span x-text="feat.feature_name"></span>
                                        <span x-text="feat.hole_placed ? 'âœ“' : '!'"></span>
                                    </span>
                                </template>
                            </div>
                        </div>
                    </template>
                </div>

                <!-- Library Tab -->
                <div x-show="leftTab === 'library'">
                    <input type="text"
                           class="form-input"
                           placeholder="Search components..."
                           x-model="componentSearch"
                           @input.debounce.300ms="searchComponents()"
                           style="margin-bottom: 0.75rem;">

                    <div id="library-results">
                        {% for comp in components %}
                        <div class="component-list-item"
                             @click="addComponent('{{ comp.id }}', '{{ comp.name }}')">
                            <h4>{{ comp.name }}</h4>
                            <div class="dims">{{ comp.length_mm }} x {{ comp.width_mm }} x {{ comp.height_mm }} mm</div>
                            <div style="font-size: 0.75rem; color: var(--text-muted);">{{ comp.manufacturer }}</div>
                        </div>
                        {% endfor %}
                    </div>
                </div>
            </div>
        </div>

        <!-- Center: Canvas -->
        <div class="editor-panel canvas-container">
            <div class="canvas-toolbar">
                <!-- Face selector dropdown -->
                <select class="face-dropdown" x-model="currentFace" @change="onFaceChange()">
                    <option value="top">Top Face</option>
                    <option value="bottom">Bottom Face</option>
                    <option value="front">Front Face</option>
                    <option value="back">Back Face</option>
                    <option value="left">Left Face</option>
                    <option value="right">Right Face</option>
                </select>

                <button class="btn btn-sm" :class="viewMode === '3d' ? 'btn-primary' : 'btn-outline'"
                        @click="setViewMode('3d')">3D</button>

                <span x-show="viewMode !== '3d' && !holePlacementMode" style="color: rgba(255,255,255,0.5); font-size: 0.7rem; margin-left: 0.5rem;">
                    Drag components/holes to position
                </span>
                <span x-show="holePlacementMode" style="color: #a5b4fc; font-size: 0.7rem; margin-left: 0.5rem;">
                    Click to place hole â€¢ ESC to cancel
                </span>
                <span x-show="viewMode === '3d'" style="color: rgba(255,255,255,0.5); font-size: 0.7rem; margin-left: 0.5rem;">
                    Drag to rotate â€¢ Scroll to zoom
                </span>
            </div>

            <div class="canvas-zoom-controls" x-show="viewMode !== '3d'">
                <button class="btn btn-sm btn-outline" @click="zoomIn()" title="Zoom In">+</button>
                <button class="btn btn-sm btn-outline" @click="zoomOut()" title="Zoom Out">âˆ’</button>
                <button class="btn btn-sm btn-outline" @click="resetZoom()" title="Reset View">âŸ²</button>
                <button class="btn btn-sm" :class="snapToGrid ? 'btn-primary' : 'btn-outline'"
                        @click="snapToGrid = !snapToGrid" title="Snap to Grid">
                    âŠž
                </button>
            </div>

            <!-- 3D View Controls -->
            <div class="canvas-zoom-controls" x-show="viewMode === '3d'">
                <button class="btn btn-sm" :class="show3DLid ? 'btn-primary' : 'btn-outline'"
                        @click="toggle3DLid()" title="Toggle Lid">
                    â¬›
                </button>
                <button class="btn btn-sm" :class="exploded3DView ? 'btn-primary' : 'btn-outline'"
                        @click="toggleExplodedView()" title="Exploded View">
                    â†•
                </button>
                <button class="btn btn-sm btn-outline" @click="reset3DView()" title="Reset View">âŸ²</button>
            </div>

            <!-- 2D Canvas -->
            <canvas id="enclosure-canvas"
                    x-show="viewMode !== '3d'"
                    :class="{ 'placement-mode': holePlacementMode }"
                    @mousedown="onCanvasMouseDown($event)"
                    @mousemove="onCanvasMouseMove($event)"
                    @mouseup="onCanvasMouseUp($event)"
                    @mouseleave="onCanvasMouseLeave($event)"
                    @wheel="onCanvasWheel($event)"
                    @dblclick="onCanvasDoubleClick($event)"
                    @keydown.escape.window="cancelPlacementMode()"></canvas>

            <!-- Placement mode indicator -->
            <div class="placement-mode-active" x-show="holePlacementMode">
                Click to place hole at cursor position
            </div>

            <!-- 3D Preview Container -->
            <div id="three-preview-container"
                 x-show="viewMode === '3d'"
                 style="width: 100%; height: 100%;"></div>

            <div class="canvas-info">
                <span x-text="currentFace.charAt(0).toUpperCase() + currentFace.slice(1) + ' face'"></span>
                <span x-text="' | ' + getFaceDimensions().width + ' x ' + getFaceDimensions().height + ' mm'"></span>
                <span x-show="selectedComponent"> | Comp: <span x-text="selectedComponent?.component_name"></span></span>
                <span x-show="selectedHole"> | Hole: <span x-text="selectedHole?.name"></span></span>
                <span x-show="zoom !== 1"> | <span x-text="Math.round(zoom * 100) + '%'"></span></span>
            </div>

            <div class="canvas-coords" x-show="mouseCoords.show">
                X: <span x-text="mouseCoords.x.toFixed(1)"></span> mm,
                Y: <span x-text="mouseCoords.y.toFixed(1)"></span> mm
            </div>
        </div>

        <!-- Right Panel: Properties & Features -->
        <div class="editor-panel">
            <div class="panel-tabs">
                <div class="panel-tab" :class="{ active: rightTab === 'features' }" @click="rightTab = 'features'">
                    Features
                </div>
                <div class="panel-tab" :class="{ active: rightTab === 'enclosure' }" @click="rightTab = 'enclosure'">
                    Enclosure
                </div>
                <div class="panel-tab" :class="{ active: rightTab === 'holes' }" @click="rightTab = 'holes'">
                    Holes
                </div>
            </div>

            <div class="panel-content">
                <!-- Features Tab -->
                <div x-show="rightTab === 'features'">
                    <template x-if="!selectedComponent">
                        <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
                            <p>Select a component to manage its features</p>
                            <p style="font-size: 0.75rem; margin-top: 0.5rem;">
                                Features are ports, buttons, and other items that may need holes in the enclosure.
                            </p>
                        </div>
                    </template>

                    <template x-if="selectedComponent">
                        <div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                                <h3 style="font-size: 1rem; margin: 0;" x-text="selectedComponent.component_name"></h3>
                                <span class="status-badge"
                                      :class="{
                                          'placed': getEnabledUnplacedCount(selectedComponent) === 0 && getEnabledCount(selectedComponent) > 0,
                                          'needs-placement': getEnabledUnplacedCount(selectedComponent) > 0,
                                          'disabled': getEnabledCount(selectedComponent) === 0
                                      }">
                                    <span x-show="getEnabledUnplacedCount(selectedComponent) > 0"
                                          x-text="getEnabledUnplacedCount(selectedComponent) + ' need holes'"></span>
                                    <span x-show="getEnabledUnplacedCount(selectedComponent) === 0 && getEnabledCount(selectedComponent) > 0">All placed</span>
                                    <span x-show="getEnabledCount(selectedComponent) === 0">No features enabled</span>
                                </span>
                            </div>
                            <p style="font-size: 0.7rem; color: var(--text-muted); margin-bottom: 1rem;">
                                Enable features that need access holes. You can rename them and add custom features.
                            </p>

                            <!-- Feature List -->
                            <template x-for="feat in selectedComponent.enabled_features" :key="feat.feature_id">
                                <div class="feature-item"
                                     :class="{
                                         'placed': feat.enabled && feat.hole_placed,
                                         'needs-placement': feat.enabled && !feat.hole_placed,
                                         'disabled': !feat.enabled
                                     }">
                                    <!-- Feature Header (always visible) -->
                                    <div class="feature-header" @click="toggleFeatureExpand(feat.feature_id)">
                                        <div class="flex items-center" style="flex: 1; min-width: 0;">
                                            <div class="feature-status-indicator"
                                                 :class="{
                                                     'placed': feat.enabled && feat.hole_placed,
                                                     'needs-placement': feat.enabled && !feat.hole_placed,
                                                     'disabled': !feat.enabled
                                                 }"></div>
                                            <div style="flex: 1; min-width: 0;">
                                                <div style="font-weight: 500; font-size: 0.875rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"
                                                     x-text="feat.feature_name"></div>
                                                <div style="font-size: 0.65rem; color: var(--text-muted);"
                                                     x-text="feat.feature_type.replace(/_/g, ' ')"></div>
                                            </div>
                                        </div>
                                        <div class="flex items-center gap-2" @click.stop>
                                            <!-- Enable/Disable Checkbox -->
                                            <label class="flex items-center gap-1" title="Enable this feature">
                                                <input type="checkbox"
                                                       :checked="feat.enabled"
                                                       @change="toggleFeature(selectedComponent.id, feat.feature_id, $event.target.checked)"
                                                       style="width: 16px; height: 16px; cursor: pointer;">
                                            </label>
                                        </div>
                                    </div>

                                    <!-- Feature Body (expandable) -->
                                    <div class="feature-body" x-show="expandedFeature === feat.feature_id" x-collapse>
                                        <!-- Feature Name (editable) -->
                                        <div class="form-group" style="margin-bottom: 0.5rem;">
                                            <label style="font-size: 0.65rem; color: var(--text-muted);">Display Name</label>
                                            <input type="text"
                                                   class="feature-name-input"
                                                   :value="feat.feature_name"
                                                   @blur="updateFeatureName(selectedComponent.id, feat.feature_id, $event.target.value)"
                                                   @keydown.enter="$event.target.blur()">
                                        </div>

                                        <!-- Feature Info -->
                                        <div class="feature-info">
                                            <div>Face: <span x-text="feat.required_face || 'any'"></span></div>
                                            <div>Size: <span x-text="(feat.hole_width_mm || 10) + ' x ' + (feat.hole_height_mm || 10) + ' mm'"></span>
                                                <span x-show="feat.is_circular">(circular)</span>
                                            </div>
                                            <template x-if="feat.is_custom">
                                                <div style="color: var(--primary);">Custom feature</div>
                                            </template>
                                        </div>

                                        <!-- Feature Actions -->
                                        <div class="feature-actions">
                                            <template x-if="feat.enabled && !feat.hole_placed">
                                                <button class="btn btn-sm btn-warning" style="flex: 1;" @click="placeHoleForFeature(feat)">
                                                    Place Hole
                                                </button>
                                            </template>
                                            <template x-if="feat.enabled && feat.hole_placed">
                                                <button class="btn btn-sm btn-success" style="flex: 1;" disabled>
                                                    âœ“ Hole Placed
                                                </button>
                                            </template>
                                            <template x-if="!feat.enabled">
                                                <button class="btn btn-sm btn-outline" style="flex: 1;" disabled>
                                                    Enable to place hole
                                                </button>
                                            </template>
                                            <template x-if="feat.is_custom">
                                                <button class="btn btn-sm btn-danger" @click="removeCustomFeature(selectedComponent.id, feat.feature_id)" title="Remove">
                                                    Ã—
                                                </button>
                                            </template>
                                        </div>
                                    </div>
                                </div>
                            </template>

                            <!-- No Features Message -->
                            <template x-if="selectedComponent.enabled_features.length === 0">
                                <div style="text-align: center; padding: 1rem; color: var(--text-muted); font-size: 0.875rem;">
                                    <p>No features defined for this component.</p>
                                    <p style="font-size: 0.75rem;">Add custom features below.</p>
                                </div>
                            </template>

                            <!-- Add Custom Feature Button -->
                            <button class="add-feature-btn" @click="showAddCustomFeature()">
                                + Add Custom Feature
                            </button>
                        </div>
                    </template>
                </div>

                <!-- Enclosure Tab -->
                <div x-show="rightTab === 'enclosure'">
                    <div class="config-section">
                        <h4>Dimensions (inner, mm)</h4>
                        <div class="config-row">
                            <label>Length (X)</label>
                            <input type="number" x-model.number="enclosure.inner_length" @change="updateEnclosure()">
                        </div>
                        <div class="config-row">
                            <label>Width (Y)</label>
                            <input type="number" x-model.number="enclosure.inner_width" @change="updateEnclosure()">
                        </div>
                        <div class="config-row">
                            <label>Height (Z)</label>
                            <input type="number" x-model.number="enclosure.inner_height" @change="updateEnclosure()">
                        </div>
                        <button class="btn btn-sm btn-outline" style="width: 100%; margin-top: 0.5rem;"
                                @click="autoSizeEnclosure()">
                            Auto-Size to Components
                        </button>
                    </div>

                    <div class="config-section">
                        <h4>Walls</h4>
                        <div class="config-row">
                            <label>Wall Thickness</label>
                            <input type="number" x-model.number="enclosure.wall_thickness" step="0.5" @change="updateEnclosure()">
                        </div>
                        <div class="config-row">
                            <label>Bottom Thickness</label>
                            <input type="number" x-model.number="enclosure.bottom_thickness" step="0.5" @change="updateEnclosure()">
                        </div>
                        <div class="config-row">
                            <label>Corner Radius</label>
                            <input type="number" x-model.number="enclosure.corner_radius" step="0.5" @change="updateEnclosure()">
                        </div>
                    </div>

                    <div class="config-section">
                        <h4>Shape</h4>
                        <select class="form-select" x-model="enclosure.shape" @change="updateEnclosure()" style="width: 100%;">
                            <option value="box">Rectangular Box</option>
                            <option value="rounded_box">Rounded Box</option>
                            <option value="cylinder">Cylinder</option>
                            <option value="hexagon">Hexagon</option>
                        </select>
                    </div>

                    <div class="config-section">
                        <h4>Lid Type</h4>
                        <select class="form-select" x-model="enclosure.lid_type" @change="updateEnclosure()" style="width: 100%;">
                            <option value="none">No Lid</option>
                            <option value="snap_fit">Snap Fit</option>
                            <option value="screw_mount">Screw Mount</option>
                            <option value="sliding">Sliding</option>
                            <option value="press_fit">Press Fit</option>
                        </select>
                    </div>
                </div>

                <!-- Holes Tab -->
                <div x-show="rightTab === 'holes'">
                    <!-- Inline Hole Form -->
                    <div class="inline-hole-form" x-show="holeForm.show">
                        <h4>
                            <span x-text="holeForm.isEditing ? 'Edit Hole' : 'New Hole'"></span>
                            <button class="btn btn-sm btn-outline" @click="cancelHoleForm()" style="padding: 0.125rem 0.375rem;">&times;</button>
                        </h4>

                        <div class="form-group">
                            <label class="form-label">Name</label>
                            <input type="text" class="form-input" x-model="holeForm.name" placeholder="Hole name">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Face</label>
                            <select class="form-select" x-model="holeForm.face" @change="syncFaceToCanvas()" style="width: 100%;">
                                <option value="front">Front</option>
                                <option value="back">Back</option>
                                <option value="left">Left</option>
                                <option value="right">Right</option>
                                <option value="top">Top</option>
                                <option value="bottom">Bottom</option>
                            </select>
                        </div>

                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label">X Position (mm)</label>
                                <input type="number" class="form-input" x-model.number="holeForm.x" step="0.5">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Y Position (mm)</label>
                                <input type="number" class="form-input" x-model.number="holeForm.y" step="0.5">
                            </div>
                        </div>

                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label">Width (mm)</label>
                                <input type="number" class="form-input" x-model.number="holeForm.width" step="0.5">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Height (mm)</label>
                                <input type="number" class="form-input" x-model.number="holeForm.height" step="0.5">
                            </div>
                        </div>

                        <label class="flex items-center gap-2" style="margin-bottom: 0.75rem; font-size: 0.8rem;">
                            <input type="checkbox" x-model="holeForm.circular">
                            <span>Circular hole</span>
                        </label>

                        <div class="flex gap-2" style="margin-bottom: 0.5rem;">
                            <button class="btn btn-sm" style="flex: 1;"
                                    :class="holePlacementMode ? 'btn-warning' : 'btn-outline'"
                                    @click="togglePlacementMode()">
                                <span x-text="holePlacementMode ? 'Cancel Placing' : 'Click to Place'"></span>
                            </button>
                        </div>

                        <div class="flex gap-2">
                            <button class="btn btn-primary btn-sm" style="flex: 1;" @click="saveHole()">
                                <span x-text="holeForm.isEditing ? 'Update Hole' : 'Add Hole'"></span>
                            </button>
                            <button class="btn btn-outline btn-sm" @click="cancelHoleForm()">Cancel</button>
                        </div>
                    </div>

                    <!-- Add Hole Button (when form is hidden) -->
                    <div x-show="!holeForm.show" style="margin-bottom: 1rem;">
                        <button class="btn btn-primary btn-sm" style="width: 100%;" @click="showNewHoleForm()">
                            + Add Custom Hole
                        </button>
                    </div>

                    <h4 style="font-size: 0.875rem; margin-bottom: 0.5rem;">Placed Holes</h4>

                    <template x-if="holes.filter(h => h.hole_type !== 'ventilation').length === 0 && !holeForm.show">
                        <p style="color: var(--text-muted); font-size: 0.875rem;">
                            No holes placed yet. Enable features on components or add custom holes.
                        </p>
                    </template>

                    <template x-for="hole in holes.filter(h => h.hole_type !== 'ventilation')" :key="hole.id">
                        <div class="hole-list-item"
                             :class="{ selected: selectedHole?.id === hole.id }"
                             @click="selectHoleForEdit(hole)">
                            <div class="flex justify-between items-center">
                                <div>
                                    <div style="font-weight: 500;" x-text="hole.name"></div>
                                    <div style="font-size: 0.7rem; color: var(--text-muted);">
                                        <span x-text="hole.face"></span> face |
                                        (<span x-text="hole.position_x_mm?.toFixed(1) || 0"></span>,
                                        <span x-text="hole.position_y_mm?.toFixed(1) || 0"></span>) |
                                        <span x-text="(hole.width_mm || 10) + 'x' + (hole.height_mm || 10)"></span>mm
                                    </div>
                                </div>
                                <button class="btn btn-sm btn-danger" @click.stop="removeHole(hole.id)" style="padding: 0.125rem 0.375rem;">
                                    &times;
                                </button>
                            </div>
                        </div>
                    </template>

                    <!-- Ventilation Zones -->
                    <h4 style="font-size: 0.875rem; margin: 1rem 0 0.5rem;">Ventilation</h4>

                    <template x-for="hole in holes.filter(h => h.hole_type === 'ventilation')" :key="hole.id">
                        <div class="hole-list-item" style="border-color: rgba(245, 158, 11, 0.5);">
                            <div class="flex justify-between items-center">
                                <div>
                                    <div style="font-weight: 500;" x-text="hole.name"></div>
                                    <div style="font-size: 0.7rem; color: var(--text-muted);">
                                        <span x-text="hole.face"></span> face |
                                        <span x-text="(hole.width_mm || hole.zone_width_mm) + 'x' + (hole.height_mm || hole.zone_height_mm)"></span>mm
                                        <span class="badge badge-warning" style="margin-left: 0.25rem;">vent</span>
                                    </div>
                                </div>
                                <button class="btn btn-sm btn-danger" @click.stop="removeHole(hole.id)" style="padding: 0.125rem 0.375rem;">
                                    &times;
                                </button>
                            </div>
                        </div>
                    </template>

                    <button class="btn btn-outline btn-sm" style="width: 100%; margin-top: 0.5rem;" @click="addVentilation()">
                        + Add Ventilation Zone
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Custom Feature Modal -->
    <div x-show="showCustomFeatureModal" x-cloak
         style="position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000;">
        <div class="card" style="width: 400px; max-width: 90vw;">
            <h3 style="margin-bottom: 1rem;">Add Custom Feature</h3>
            <p style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 1rem;">
                Add a custom feature that requires a hole in the enclosure.
            </p>

            <div class="form-group">
                <label class="form-label">Feature Name *</label>
                <input type="text" class="form-input" x-model="customFeatureForm.name"
                       placeholder="e.g., Power Switch, Sensor Window">
            </div>

            <div class="form-group">
                <label class="form-label">Feature Type</label>
                <select class="form-select" x-model="customFeatureForm.feature_type" style="width: 100%;">
                    <option value="cable_entry">Cable Entry</option>
                    <option value="button">Button</option>
                    <option value="switch">Switch</option>
                    <option value="led_indicator">LED Indicator</option>
                    <option value="sensor_window">Sensor Window</option>
                    <option value="display">Display</option>
                    <option value="usb_port">USB Port</option>
                    <option value="power_input">Power Input</option>
                    <option value="audio_jack">Audio Jack</option>
                    <option value="ventilation">Ventilation</option>
                    <option value="mounting_hole">Mounting Hole</option>
                </select>
            </div>

            <div class="form-group">
                <label class="form-label">Suggested Face</label>
                <select class="form-select" x-model="customFeatureForm.face" style="width: 100%;">
                    <option value="front">Front</option>
                    <option value="back">Back</option>
                    <option value="left">Left</option>
                    <option value="right">Right</option>
                    <option value="top">Top</option>
                    <option value="bottom">Bottom</option>
                </select>
            </div>

            <div class="grid grid-2" style="gap: 0.75rem;">
                <div class="form-group">
                    <label class="form-label">Hole Width (mm)</label>
                    <input type="number" class="form-input" x-model.number="customFeatureForm.width" step="0.5" min="1">
                </div>
                <div class="form-group">
                    <label class="form-label">Hole Height (mm)</label>
                    <input type="number" class="form-input" x-model.number="customFeatureForm.height" step="0.5" min="1">
                </div>
            </div>

            <label class="flex items-center gap-2" style="margin-bottom: 1rem;">
                <input type="checkbox" x-model="customFeatureForm.circular">
                <span>Circular hole</span>
            </label>

            <div class="flex gap-2">
                <button class="btn btn-primary" style="flex: 1;" @click="addCustomFeature()">
                    Add Feature
                </button>
                <button class="btn btn-outline" @click="showCustomFeatureModal = false">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Hole Placement Modal -->
    <div x-show="showHoleModal" x-cloak
         style="position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000;">
        <div class="card" style="width: 400px; max-width: 90vw;">
            <h3 style="margin-bottom: 1rem;">Place Hole: <span x-text="holeModal.name"></span></h3>

            <div class="form-group">
                <label class="form-label">Face</label>
                <div class="face-selector">
                    <div></div>
                    <div class="face-btn" :class="{ selected: holeModal.face === 'back' }"
                         @click="holeModal.face = 'back'">Back</div>
                    <div></div>
                    <div class="face-btn" :class="{ selected: holeModal.face === 'left' }"
                         @click="holeModal.face = 'left'">Left</div>
                    <div class="face-btn" :class="{ selected: holeModal.face === 'top' }"
                         @click="holeModal.face = 'top'">Top</div>
                    <div class="face-btn" :class="{ selected: holeModal.face === 'right' }"
                         @click="holeModal.face = 'right'">Right</div>
                    <div></div>
                    <div class="face-btn" :class="{ selected: holeModal.face === 'front' }"
                         @click="holeModal.face = 'front'">Front</div>
                    <div></div>
                </div>
            </div>

            <div class="grid grid-2" style="gap: 0.75rem;">
                <div class="form-group">
                    <label class="form-label">X Position (mm)</label>
                    <input type="number" class="form-input" x-model.number="holeModal.x" step="0.5">
                </div>
                <div class="form-group">
                    <label class="form-label">Y Position (mm)</label>
                    <input type="number" class="form-input" x-model.number="holeModal.y" step="0.5">
                </div>
            </div>

            <div class="grid grid-2" style="gap: 0.75rem;">
                <div class="form-group">
                    <label class="form-label">Width (mm)</label>
                    <input type="number" class="form-input" x-model.number="holeModal.width" step="0.5">
                </div>
                <div class="form-group">
                    <label class="form-label">Height (mm)</label>
                    <input type="number" class="form-input" x-model.number="holeModal.height" step="0.5">
                </div>
            </div>

            <label class="flex items-center gap-2" style="margin-bottom: 1rem;">
                <input type="checkbox" x-model="holeModal.circular">
                <span>Circular hole</span>
            </label>

            <div class="flex gap-2">
                <button class="btn btn-primary" style="flex: 1;" @click="confirmHolePlacement()">
                    Place Hole
                </button>
                <button class="btn btn-outline" @click="showHoleModal = false">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Ventilation Zone Modal -->
    <div x-show="showVentModal" x-cloak
         style="position: fixed; inset: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000;">
        <div class="card" style="width: 500px; max-width: 95vw; max-height: 90vh; overflow-y: auto;">
            <h3 style="margin-bottom: 1rem;">Add Ventilation Zone</h3>

            <div class="form-group">
                <label class="form-label">Pattern Type</label>
                <select class="form-select" x-model="ventModal.pattern" style="width: 100%;">
                    <option value="grid">Grid of Round Holes</option>
                    <option value="slots_horizontal">Horizontal Slots</option>
                    <option value="slots_vertical">Vertical Slots</option>
                    <option value="honeycomb">Honeycomb Pattern</option>
                    <option value="louvers">Angled Louvers</option>
                </select>
            </div>

            <div class="form-group">
                <label class="form-label">Face</label>
                <div class="face-selector">
                    <div></div>
                    <div class="face-btn" :class="{ selected: ventModal.face === 'back' }"
                         @click="ventModal.face = 'back'">Back</div>
                    <div></div>
                    <div class="face-btn" :class="{ selected: ventModal.face === 'left' }"
                         @click="ventModal.face = 'left'">Left</div>
                    <div class="face-btn" :class="{ selected: ventModal.face === 'top' }"
                         @click="ventModal.face = 'top'">Top</div>
                    <div class="face-btn" :class="{ selected: ventModal.face === 'right' }"
                         @click="ventModal.face = 'right'">Right</div>
                    <div></div>
                    <div class="face-btn" :class="{ selected: ventModal.face === 'front' }"
                         @click="ventModal.face = 'front'">Front</div>
                    <div></div>
                </div>
            </div>

            <h4 style="font-size: 0.875rem; color: var(--text-muted); margin: 1rem 0 0.5rem;">Zone Position & Size</h4>

            <div class="grid grid-2" style="gap: 0.75rem;">
                <div class="form-group">
                    <label class="form-label">X Position (mm)</label>
                    <input type="number" class="form-input" x-model.number="ventModal.x" step="1">
                </div>
                <div class="form-group">
                    <label class="form-label">Y Position (mm)</label>
                    <input type="number" class="form-input" x-model.number="ventModal.y" step="1">
                </div>
            </div>

            <div class="grid grid-2" style="gap: 0.75rem;">
                <div class="form-group">
                    <label class="form-label">Zone Width (mm)</label>
                    <input type="number" class="form-input" x-model.number="ventModal.zoneWidth" step="1">
                </div>
                <div class="form-group">
                    <label class="form-label">Zone Height (mm)</label>
                    <input type="number" class="form-input" x-model.number="ventModal.zoneHeight" step="1">
                </div>
            </div>

            <h4 style="font-size: 0.875rem; color: var(--text-muted); margin: 1rem 0 0.5rem;">Pattern Settings</h4>

            <!-- Grid pattern settings -->
            <template x-if="ventModal.pattern === 'grid' || ventModal.pattern === 'honeycomb'">
                <div class="grid grid-2" style="gap: 0.75rem;">
                    <div class="form-group">
                        <label class="form-label">Hole Diameter (mm)</label>
                        <input type="number" class="form-input" x-model.number="ventModal.holeDiameter" step="0.5" min="1">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Spacing (mm)</label>
                        <input type="number" class="form-input" x-model.number="ventModal.spacing" step="0.5" min="1">
                    </div>
                </div>
            </template>

            <!-- Slot pattern settings -->
            <template x-if="ventModal.pattern === 'slots_horizontal' || ventModal.pattern === 'slots_vertical'">
                <div class="grid grid-2" style="gap: 0.75rem;">
                    <div class="form-group">
                        <label class="form-label">Slot Width (mm)</label>
                        <input type="number" class="form-input" x-model.number="ventModal.slotWidth" step="0.5" min="1">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Slot Length (mm)</label>
                        <input type="number" class="form-input" x-model.number="ventModal.slotLength" step="1" min="5">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Slot Spacing (mm)</label>
                        <input type="number" class="form-input" x-model.number="ventModal.slotSpacing" step="0.5" min="1">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Corner Radius (mm)</label>
                        <input type="number" class="form-input" x-model.number="ventModal.cornerRadius" step="0.5" min="0">
                    </div>
                </div>
            </template>

            <!-- Louver settings -->
            <template x-if="ventModal.pattern === 'louvers'">
                <div class="grid grid-2" style="gap: 0.75rem;">
                    <div class="form-group">
                        <label class="form-label">Louver Width (mm)</label>
                        <input type="number" class="form-input" x-model.number="ventModal.louverWidth" step="0.5" min="1">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Louver Angle (deg)</label>
                        <input type="number" class="form-input" x-model.number="ventModal.louverAngle" step="5" min="15" max="75">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Louver Count</label>
                        <input type="number" class="form-input" x-model.number="ventModal.louverCount" step="1" min="2" max="20">
                    </div>
                </div>
            </template>

            <!-- Preview -->
            <div style="margin: 1rem 0; padding: 1rem; background: #1a1a2e; border-radius: 0.5rem;">
                <div style="color: #888; font-size: 0.75rem; margin-bottom: 0.5rem;">Preview</div>
                <canvas id="vent-preview-canvas" width="200" height="100" style="width: 100%; background: #2a2a4e; border-radius: 0.25rem;"></canvas>
                <div style="color: #4a9eff; font-size: 0.75rem; margin-top: 0.5rem;">
                    Est. <span x-text="calculateVentHoleCount()"></span> hole(s) |
                    Open area: ~<span x-text="calculateOpenArea()"></span>%
                </div>
            </div>

            <div class="flex gap-2">
                <button class="btn btn-primary" style="flex: 1;" @click="confirmVentilation()">
                    Add Ventilation
                </button>
                <button class="btn btn-outline" @click="showVentModal = false">Cancel</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
const PROJECT_ID = '{{ project.id }}';

function projectEditor() {
    return {
        // UI State
        leftTab: 'project',
        rightTab: 'features',
        viewMode: 'top',
        currentFace: 'top',  // Which face is displayed on canvas
        selectedComponent: null,
        selectedHole: null,  // Currently selected hole for editing
        showHoleModal: false,
        showVentModal: false,
        showCustomFeatureModal: false,  // Add custom feature modal
        expandedFeature: null,  // Which feature is expanded in the list

        // Custom feature form
        customFeatureForm: {
            name: '',
            feature_type: 'cable_entry',
            face: 'front',
            width: 10,
            height: 10,
            circular: false
        },

        // Hole placement state
        holePlacementMode: false,  // When true, click places hole
        pendingHole: null,  // Ghost hole preview data
        isDraggingHole: false,  // Dragging a hole
        dragHole: null,  // Hole being dragged

        // Inline hole form state
        holeForm: {
            show: false,
            isEditing: false,
            editingHoleId: null,
            name: 'Custom Hole',
            face: 'front',
            x: 10,
            y: 10,
            width: 10,
            height: 10,
            circular: false,
            componentId: null,
            featureId: null
        },

        // Canvas interaction state
        isDragging: false,
        dragComponent: null,
        dragStartPos: { x: 0, y: 0 },
        dragOffset: { x: 0, y: 0 },
        isPanning: false,
        panStart: { x: 0, y: 0 },
        panOffset: { x: 0, y: 0 },
        zoom: 1,
        snapToGrid: true,
        gridSize: 5, // mm
        mouseCoords: { x: 0, y: 0, show: false },

        // 3D Preview state
        preview3D: null,
        show3DLid: true,
        exploded3DView: false,

        // Component dimensions cache (loaded from server)
        componentDimensions: {},

        // Data
        projectComponents: {{ project.components | tojson if project.components else '[]' | safe }},
        enclosure: {
            inner_length: {{ project.enclosure_config.dimensions.inner_length_mm if project.enclosure_config else 100 }},
            inner_width: {{ project.enclosure_config.dimensions.inner_width_mm if project.enclosure_config else 60 }},
            inner_height: {{ project.enclosure_config.dimensions.inner_height_mm if project.enclosure_config else 30 }},
            wall_thickness: {{ project.enclosure_config.wall_thickness_mm if project.enclosure_config else 2 }},
            bottom_thickness: {{ project.enclosure_config.bottom_thickness_mm if project.enclosure_config else 2 }},
            corner_radius: {{ project.enclosure_config.corner_radius_mm if project.enclosure_config else 0 }},
            shape: '{{ project.enclosure_config.shape if project.enclosure_config else "box" }}',
            lid_type: '{{ project.enclosure_config.lid.type if project.enclosure_config else "snap_fit" }}'
        },
        holes: {{ project.enclosure_config.holes if project.enclosure_config else '[]' | safe }},

        // Modal data
        holeModal: {
            name: '',
            face: 'front',
            x: 10,
            y: 10,
            width: 10,
            height: 10,
            circular: false,
            componentId: null,
            featureId: null
        },

        // Ventilation modal data
        ventModal: {
            pattern: 'grid',
            face: 'top',
            x: 10,
            y: 10,
            zoneWidth: 40,
            zoneHeight: 30,
            // Grid/honeycomb settings
            holeDiameter: 3,
            spacing: 5,
            // Slot settings
            slotWidth: 2,
            slotLength: 15,
            slotSpacing: 4,
            cornerRadius: 1,
            // Louver settings
            louverWidth: 3,
            louverAngle: 45,
            louverCount: 5
        },

        // Ventilation zones (stored separately from individual holes)
        ventilationZones: [],

        componentSearch: '',

        get unplacedCount() {
            let count = 0;
            for (const comp of this.projectComponents) {
                for (const feat of comp.enabled_features || []) {
                    if (feat.enabled && !feat.hole_placed) {
                        count++;
                    }
                }
            }
            return count;
        },

        // Helper functions for feature status
        getEnabledCount(comp) {
            return (comp.enabled_features || []).filter(f => f.enabled).length;
        },

        getEnabledUnplacedCount(comp) {
            return (comp.enabled_features || []).filter(f => f.enabled && !f.hole_placed).length;
        },

        toggleFeatureExpand(featureId) {
            this.expandedFeature = this.expandedFeature === featureId ? null : featureId;
        },

        async updateFeatureName(componentId, featureId, newName) {
            // Update locally
            const comp = this.projectComponents.find(c => c.id === componentId);
            if (comp) {
                const feat = comp.enabled_features.find(f => f.feature_id === featureId);
                if (feat) {
                    feat.feature_name = newName;
                }
            }

            // Save to server
            try {
                await fetch(`/projects/api/${PROJECT_ID}/components/${componentId}/features/${featureId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ feature_name: newName })
                });
            } catch (e) {
                console.error('Failed to update feature name:', e);
            }

            // Update canvas if hole is placed
            this.redrawCanvas();
        },

        showAddCustomFeature() {
            this.customFeatureForm = {
                name: 'Custom Feature',
                feature_type: 'cable_entry',
                face: 'front',
                width: 10,
                height: 10,
                circular: false
            };
            this.showCustomFeatureModal = true;
        },

        async addCustomFeature() {
            if (!this.selectedComponent) return;

            const componentId = this.selectedComponent.id;

            try {
                const response = await fetch(`/projects/api/${PROJECT_ID}/components/${componentId}/features`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        feature_name: this.customFeatureForm.name,
                        feature_type: this.customFeatureForm.feature_type,
                        required_face: this.customFeatureForm.face,
                        hole_width_mm: this.customFeatureForm.width,
                        hole_height_mm: this.customFeatureForm.height,
                        is_circular: this.customFeatureForm.circular,
                        is_custom: true
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    // Add to local state
                    this.selectedComponent.enabled_features.push(data.feature);
                    this.showCustomFeatureModal = false;
                }
            } catch (e) {
                console.error('Failed to add custom feature:', e);
            }
        },

        async removeCustomFeature(componentId, featureId) {
            try {
                const response = await fetch(`/projects/api/${PROJECT_ID}/components/${componentId}/features/${featureId}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    const comp = this.projectComponents.find(c => c.id === componentId);
                    if (comp) {
                        comp.enabled_features = comp.enabled_features.filter(f => f.feature_id !== featureId);
                    }
                }
            } catch (e) {
                console.error('Failed to remove custom feature:', e);
            }
        },

        init() {
            this.initCanvas();
            this.loadComponentDimensions();

            // Watch for ventilation modal changes to update preview
            this.$watch('ventModal', () => {
                if (this.showVentModal) {
                    this.drawVentPreview();
                }
            }, { deep: true });

            this.$watch('showVentModal', (show) => {
                if (show) {
                    this.$nextTick(() => this.drawVentPreview());
                }
            });
        },

        async loadComponentDimensions() {
            // Load dimensions for all project components
            for (const comp of this.projectComponents) {
                if (!this.componentDimensions[comp.component_id]) {
                    try {
                        const response = await fetch(`/components/api/${comp.component_id}`);
                        if (response.ok) {
                            const data = await response.json();
                            this.componentDimensions[comp.component_id] = {
                                length: data.dimensions?.length_mm || 25,
                                width: data.dimensions?.width_mm || 18,
                                height: data.dimensions?.height_mm || 10
                            };
                        }
                    } catch (e) {
                        // Use defaults
                        this.componentDimensions[comp.component_id] = { length: 25, width: 18, height: 10 };
                    }
                }
            }
            this.redrawCanvas();
        },

        initCanvas() {
            const canvas = document.getElementById('enclosure-canvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            this.resizeCanvas(canvas);
            this.drawEnclosure(ctx, canvas);

            // Redraw on resize
            window.addEventListener('resize', () => {
                this.resizeCanvas(canvas);
                this.drawEnclosure(ctx, canvas);
            });
        },

        resizeCanvas(canvas) {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
        },

        redrawCanvas() {
            const canvas = document.getElementById('enclosure-canvas');
            if (canvas) {
                this.drawEnclosure(canvas.getContext('2d'), canvas);
            }
        },

        // Canvas coordinate conversion
        getCanvasTransform(canvas) {
            const padding = 60;
            const maxWidth = canvas.width - 2 * padding;
            const maxHeight = canvas.height - 2 * padding;

            // Use currentFace to determine dimensions
            const faceDims = this.getFaceDimensions();
            const drawWidth = faceDims.width;
            const drawHeight = faceDims.height;

            const baseScale = Math.min(maxWidth / drawWidth, maxHeight / drawHeight);
            const scale = baseScale * this.zoom;
            const offsetX = (canvas.width - drawWidth * scale) / 2 + this.panOffset.x;
            const offsetY = (canvas.height - drawHeight * scale) / 2 + this.panOffset.y;

            return { scale, offsetX, offsetY, drawWidth, drawHeight };
        },

        screenToWorld(canvas, screenX, screenY) {
            const { scale, offsetX, offsetY } = this.getCanvasTransform(canvas);
            return {
                x: (screenX - offsetX) / scale,
                y: (screenY - offsetY) / scale
            };
        },

        worldToScreen(canvas, worldX, worldY) {
            const { scale, offsetX, offsetY } = this.getCanvasTransform(canvas);
            return {
                x: worldX * scale + offsetX,
                y: worldY * scale + offsetY
            };
        },

        // Mouse event handlers
        onCanvasMouseDown(e) {
            const canvas = e.target;
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const worldPos = this.screenToWorld(canvas, screenX, screenY);

            // If in placement mode, place the hole
            if (this.holePlacementMode) {
                let x = worldPos.x - this.holeForm.width / 2;
                let y = worldPos.y - this.holeForm.height / 2;

                // Snap to grid
                if (this.snapToGrid) {
                    x = Math.round(x / this.gridSize) * this.gridSize;
                    y = Math.round(y / this.gridSize) * this.gridSize;
                }

                // Clamp to face bounds
                const faceDims = this.getFaceDimensions();
                x = Math.max(0, Math.min(x, faceDims.width - this.holeForm.width));
                y = Math.max(0, Math.min(y, faceDims.height - this.holeForm.height));

                this.holeForm.x = x;
                this.holeForm.y = y;
                this.holePlacementMode = false;
                this.pendingHole = null;
                this.redrawCanvas();
                return;
            }

            // Check if clicking on a hole (for dragging)
            const clickedHole = this.getHoleAtPosition(worldPos.x, worldPos.y);
            if (clickedHole) {
                this.isDraggingHole = true;
                this.dragHole = clickedHole;
                this.dragOffset = {
                    x: worldPos.x - (clickedHole.position_x_mm || 0),
                    y: worldPos.y - (clickedHole.position_y_mm || 0)
                };
                this.selectHoleForEdit(clickedHole);
                canvas.classList.add('drag-component');
                return;
            }

            // Check if clicking on a component (now works in all views)
            const clickedComp = this.getComponentAtPosition(worldPos.x, worldPos.y);

            if (clickedComp) {
                // Start dragging component
                this.isDragging = true;
                this.dragComponent = clickedComp;
                this.dragStartPos = { x: worldPos.x, y: worldPos.y };

                // Calculate drag offset based on current face view
                let offsetX, offsetY;
                switch (this.currentFace) {
                    case 'top':
                    case 'bottom':
                        offsetX = worldPos.x - (clickedComp.position?.x_mm || 0);
                        offsetY = worldPos.y - (clickedComp.position?.y_mm || 0);
                        break;
                    case 'front':
                    case 'back':
                        offsetX = worldPos.x - (clickedComp.position?.x_mm || 0);
                        offsetY = worldPos.y - (clickedComp.position?.z_mm || 0);
                        break;
                    case 'left':
                    case 'right':
                        offsetX = worldPos.x - (clickedComp.position?.y_mm || 0);
                        offsetY = worldPos.y - (clickedComp.position?.z_mm || 0);
                        break;
                    default:
                        offsetX = worldPos.x - (clickedComp.position?.x_mm || 0);
                        offsetY = worldPos.y - (clickedComp.position?.y_mm || 0);
                }
                this.dragOffset = { x: offsetX, y: offsetY };

                this.selectComponent(clickedComp);
                canvas.classList.add('drag-component');
            } else if (e.button === 0 && !clickedComp && !clickedHole) {
                // Start panning
                this.isPanning = true;
                this.panStart = { x: screenX, y: screenY };
                canvas.classList.add('dragging');
            }
        },

        onCanvasMouseMove(e) {
            const canvas = e.target;
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const worldPos = this.screenToWorld(canvas, screenX, screenY);

            // Get face dimensions for clamping
            const faceDims = this.getFaceDimensions();

            // Update mouse coordinates display
            this.mouseCoords = {
                x: Math.max(0, Math.min(worldPos.x, faceDims.width)),
                y: Math.max(0, Math.min(worldPos.y, faceDims.height)),
                show: true
            };

            // Update pending hole position (ghost preview) in placement mode
            if (this.holePlacementMode && this.pendingHole) {
                let x = worldPos.x - this.holeForm.width / 2;
                let y = worldPos.y - this.holeForm.height / 2;

                if (this.snapToGrid) {
                    x = Math.round(x / this.gridSize) * this.gridSize;
                    y = Math.round(y / this.gridSize) * this.gridSize;
                }

                x = Math.max(0, Math.min(x, faceDims.width - this.holeForm.width));
                y = Math.max(0, Math.min(y, faceDims.height - this.holeForm.height));

                this.pendingHole.x = x;
                this.pendingHole.y = y;
                this.redrawCanvas();
                return;
            }

            // Dragging a hole
            if (this.isDraggingHole && this.dragHole) {
                let newX = worldPos.x - this.dragOffset.x;
                let newY = worldPos.y - this.dragOffset.y;

                if (this.snapToGrid) {
                    newX = Math.round(newX / this.gridSize) * this.gridSize;
                    newY = Math.round(newY / this.gridSize) * this.gridSize;
                }

                const hw = this.dragHole.width_mm || 10;
                const hh = this.dragHole.height_mm || 10;
                newX = Math.max(0, Math.min(newX, faceDims.width - hw));
                newY = Math.max(0, Math.min(newY, faceDims.height - hh));

                this.dragHole.position_x_mm = newX;
                this.dragHole.position_y_mm = newY;

                // Update form values in real-time
                if (this.holeForm.show && this.holeForm.editingHoleId === this.dragHole.id) {
                    this.holeForm.x = newX;
                    this.holeForm.y = newY;
                }

                this.redrawCanvas();
                return;
            }

            if (this.isDragging && this.dragComponent) {
                // Update component position based on current face view
                let newX = worldPos.x - this.dragOffset.x;
                let newY = worldPos.y - this.dragOffset.y;

                // Snap to grid if enabled
                if (this.snapToGrid) {
                    newX = Math.round(newX / this.gridSize) * this.gridSize;
                    newY = Math.round(newY / this.gridSize) * this.gridSize;
                }

                const dims = this.componentDimensions[this.dragComponent.component_id] || { length: 25, width: 18, height: 10 };
                this.dragComponent.position = this.dragComponent.position || { x_mm: 0, y_mm: 0, z_mm: 0 };

                // Update the correct coordinates based on current face view
                switch (this.currentFace) {
                    case 'top':
                    case 'bottom':
                        // Top/bottom view: drag affects x_mm and y_mm
                        newX = Math.max(0, Math.min(newX, this.enclosure.inner_length - dims.length));
                        newY = Math.max(0, Math.min(newY, this.enclosure.inner_width - dims.width));
                        this.dragComponent.position.x_mm = newX;
                        this.dragComponent.position.y_mm = newY;
                        break;
                    case 'front':
                    case 'back':
                        // Front/back view: drag affects x_mm and z_mm
                        newX = Math.max(0, Math.min(newX, this.enclosure.inner_length - dims.length));
                        newY = Math.max(0, Math.min(newY, this.enclosure.inner_height - dims.height));
                        this.dragComponent.position.x_mm = newX;
                        this.dragComponent.position.z_mm = newY;
                        break;
                    case 'left':
                    case 'right':
                        // Left/right view: drag affects y_mm and z_mm
                        newX = Math.max(0, Math.min(newX, this.enclosure.inner_width - dims.width));
                        newY = Math.max(0, Math.min(newY, this.enclosure.inner_height - dims.height));
                        this.dragComponent.position.y_mm = newX;
                        this.dragComponent.position.z_mm = newY;
                        break;
                }

                this.redrawCanvas();
            } else if (this.isPanning) {
                // Update pan offset
                const dx = screenX - this.panStart.x;
                const dy = screenY - this.panStart.y;
                this.panOffset.x += dx;
                this.panOffset.y += dy;
                this.panStart = { x: screenX, y: screenY };
                this.redrawCanvas();
            }
        },

        onCanvasMouseUp(e) {
            const canvas = document.getElementById('enclosure-canvas');

            // Save hole position after dragging
            if (this.isDraggingHole && this.dragHole) {
                this.updateHolePosition(this.dragHole.id, {
                    name: this.dragHole.name,
                    face: this.dragHole.face,
                    position_x_mm: this.dragHole.position_x_mm,
                    position_y_mm: this.dragHole.position_y_mm,
                    width_mm: this.dragHole.width_mm,
                    height_mm: this.dragHole.height_mm,
                    is_circular: this.dragHole.is_circular
                });
                canvas.classList.remove('drag-component');
            }

            if (this.isDragging && this.dragComponent) {
                // Save the new position to the server
                this.updateComponentPosition(this.dragComponent);
                canvas.classList.remove('drag-component');
            }

            if (this.isPanning) {
                canvas.classList.remove('dragging');
            }

            this.isDragging = false;
            this.dragComponent = null;
            this.isDraggingHole = false;
            this.dragHole = null;
            this.isPanning = false;
            this.mouseCoords.show = false;
        },

        onCanvasWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            this.zoom = Math.max(0.25, Math.min(4, this.zoom * delta));
            this.redrawCanvas();
        },

        onCanvasDoubleClick(e) {
            const canvas = e.target;
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const worldPos = this.screenToWorld(canvas, screenX, screenY);

            const clickedComp = this.getComponentAtPosition(worldPos.x, worldPos.y);
            if (clickedComp) {
                this.selectComponent(clickedComp);
                this.rightTab = 'features';
            }
        },

        getComponentAtPosition(x, y) {
            // Skip if in 3D view
            if (this.viewMode === '3d') return null;

            for (const comp of [...this.projectComponents].reverse()) {
                // Skip locked components
                if (comp.locked) continue;

                const dims = this.componentDimensions[comp.component_id] || { length: 25, width: 18, height: 10 };

                // Get component position and size based on current face view
                let cx, cy, cw, ch;

                switch (this.currentFace) {
                    case 'top':
                    case 'bottom':
                        // Top/bottom view: X=x_mm, Y=y_mm, size=length x width
                        cx = comp.position?.x_mm || 0;
                        cy = comp.position?.y_mm || 0;
                        cw = dims.length;
                        ch = dims.width;
                        break;
                    case 'front':
                    case 'back':
                        // Front/back view: X=x_mm, Y=z_mm, size=length x height
                        cx = comp.position?.x_mm || 0;
                        cy = comp.position?.z_mm || 0;
                        cw = dims.length;
                        ch = dims.height;
                        break;
                    case 'left':
                    case 'right':
                        // Left/right view: X=y_mm, Y=z_mm, size=width x height
                        cx = comp.position?.y_mm || 0;
                        cy = comp.position?.z_mm || 0;
                        cw = dims.width;
                        ch = dims.height;
                        break;
                    default:
                        cx = comp.position?.x_mm || 0;
                        cy = comp.position?.y_mm || 0;
                        cw = dims.length;
                        ch = dims.width;
                }

                if (x >= cx && x <= cx + cw && y >= cy && y <= cy + ch) {
                    return comp;
                }
            }
            return null;
        },

        async updateComponentPosition(comp) {
            try {
                await fetch(`/projects/api/${PROJECT_ID}/components/${comp.id}/position`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        x_mm: comp.position.x_mm,
                        y_mm: comp.position.y_mm,
                        z_mm: comp.position.z_mm || 0
                    })
                });
            } catch (e) {
                console.error('Failed to update position:', e);
            }
        },

        async toggleComponentLock(comp, locked) {
            comp.locked = locked;
            try {
                await fetch(`/projects/api/${PROJECT_ID}/components/${comp.id}/lock`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ locked })
                });
            } catch (e) {
                console.error('Failed to update lock state:', e);
                comp.locked = !locked;  // Revert on failure
            }
            this.redrawCanvas();
        },

        zoomIn() {
            this.zoom = Math.min(4, this.zoom * 1.25);
            this.redrawCanvas();
        },

        zoomOut() {
            this.zoom = Math.max(0.25, this.zoom / 1.25);
            this.redrawCanvas();
        },

        resetZoom() {
            this.zoom = 1;
            this.panOffset = { x: 0, y: 0 };
            this.redrawCanvas();
        },

        // Face selector methods
        onFaceChange() {
            // Switch canvas view to show the selected face
            if (this.currentFace === 'top' || this.currentFace === 'bottom') {
                this.viewMode = 'top';
            } else if (this.currentFace === 'front' || this.currentFace === 'back') {
                this.viewMode = 'front';
            } else {
                this.viewMode = 'side';
            }
            this.resetZoom();
            this.redrawCanvas();
        },

        syncFaceToCanvas() {
            // When face changes in form, update canvas to show that face
            this.currentFace = this.holeForm.face;
            this.onFaceChange();
        },

        getFaceDimensions() {
            // Get width/height for the current face view
            const e = this.enclosure;
            switch (this.currentFace) {
                case 'top':
                case 'bottom':
                    return { width: e.inner_length, height: e.inner_width };
                case 'front':
                case 'back':
                    return { width: e.inner_length, height: e.inner_height };
                case 'left':
                case 'right':
                    return { width: e.inner_width, height: e.inner_height };
            }
            return { width: e.inner_length, height: e.inner_width };
        },

        // Inline hole form methods
        showNewHoleForm() {
            this.holeForm = {
                show: true,
                isEditing: false,
                editingHoleId: null,
                name: 'Custom Hole',
                face: this.currentFace,
                x: 10,
                y: 10,
                width: 10,
                height: 10,
                circular: false,
                componentId: null,
                featureId: null
            };
            this.rightTab = 'holes';
        },

        selectHoleForEdit(hole) {
            this.selectedHole = hole;
            this.holeForm = {
                show: true,
                isEditing: true,
                editingHoleId: hole.id,
                name: hole.name,
                face: hole.face,
                x: hole.position_x_mm || 0,
                y: hole.position_y_mm || 0,
                width: hole.width_mm || 10,
                height: hole.height_mm || 10,
                circular: hole.is_circular || false,
                componentId: hole.component_id,
                featureId: hole.feature_id
            };
            // Switch canvas to show this hole's face
            this.currentFace = hole.face;
            this.onFaceChange();
            this.redrawCanvas();
        },

        cancelHoleForm() {
            this.holeForm.show = false;
            this.holePlacementMode = false;
            this.pendingHole = null;
            this.selectedHole = null;
            this.redrawCanvas();
        },

        async saveHole() {
            if (this.holeForm.isEditing) {
                // Update existing hole
                await this.updateHolePosition(this.holeForm.editingHoleId, {
                    name: this.holeForm.name,
                    face: this.holeForm.face,
                    position_x_mm: this.holeForm.x,
                    position_y_mm: this.holeForm.y,
                    width_mm: this.holeForm.width,
                    height_mm: this.holeForm.height,
                    is_circular: this.holeForm.circular
                });
            } else {
                // Create new hole
                await this.createHole();
            }
            this.cancelHoleForm();
        },

        async createHole() {
            const response = await fetch(`/projects/api/${PROJECT_ID}/holes`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: this.holeForm.name,
                    face: this.holeForm.face,
                    x: this.holeForm.x,
                    y: this.holeForm.y,
                    width: this.holeForm.width,
                    height: this.holeForm.height,
                    is_circular: this.holeForm.circular,
                    hole_type: 'component_access',
                    component_id: this.holeForm.componentId,
                    feature_id: this.holeForm.featureId
                })
            });

            if (response.ok) {
                const data = await response.json();
                this.holes.push(data.hole);

                // Update feature state if linked to a feature
                if (this.holeForm.componentId && this.holeForm.featureId) {
                    const comp = this.projectComponents.find(c => c.id === this.holeForm.componentId);
                    if (comp) {
                        const feat = comp.enabled_features.find(f => f.feature_id === this.holeForm.featureId);
                        if (feat) {
                            feat.hole_placed = true;
                            feat.hole_id = data.hole.id;
                        }
                    }
                }

                this.redrawCanvas();
                if (this.viewMode === '3d') {
                    this.update3DPreview();
                }
            }
        },

        async updateHolePosition(holeId, updates) {
            const response = await fetch(`/projects/api/${PROJECT_ID}/holes/${holeId}/position`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(updates)
            });

            if (response.ok) {
                // Update local state
                const hole = this.holes.find(h => h.id === holeId);
                if (hole) {
                    Object.assign(hole, {
                        name: updates.name,
                        face: updates.face,
                        position_x_mm: updates.position_x_mm,
                        position_y_mm: updates.position_y_mm,
                        width_mm: updates.width_mm,
                        height_mm: updates.height_mm,
                        is_circular: updates.is_circular
                    });
                }
                this.redrawCanvas();
                if (this.viewMode === '3d') {
                    this.update3DPreview();
                }
            }
        },

        // Placement mode methods
        togglePlacementMode() {
            this.holePlacementMode = !this.holePlacementMode;
            if (this.holePlacementMode) {
                // Initialize pending hole for ghost preview
                this.pendingHole = {
                    x: this.holeForm.x,
                    y: this.holeForm.y,
                    width: this.holeForm.width,
                    height: this.holeForm.height,
                    circular: this.holeForm.circular
                };
            } else {
                this.pendingHole = null;
            }
            this.redrawCanvas();
        },

        cancelPlacementMode() {
            if (this.holePlacementMode) {
                this.holePlacementMode = false;
                this.pendingHole = null;
                this.redrawCanvas();
            }
        },

        // Get hole at a position (for clicking/dragging)
        getHoleAtPosition(x, y) {
            // Only check holes on current face
            const faceHoles = this.holes.filter(h => h.face === this.currentFace);

            for (const hole of [...faceHoles].reverse()) {
                const hx = hole.position_x_mm || 0;
                const hy = hole.position_y_mm || 0;
                const hw = hole.width_mm || 10;
                const hh = hole.height_mm || 10;

                if (x >= hx && x <= hx + hw && y >= hy && y <= hy + hh) {
                    return hole;
                }
            }
            return null;
        },

        onCanvasMouseLeave(e) {
            this.onCanvasMouseUp(e);
            this.mouseCoords.show = false;
        },

        drawEnclosure(ctx, canvas) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const { scale, offsetX, offsetY, drawWidth, drawHeight } = this.getCanvasTransform(canvas);

            const w = drawWidth * scale;
            const h = drawHeight * scale;

            // Draw grid first (behind everything)
            this.drawGrid(ctx, scale, offsetX, offsetY, w, h);

            // Draw enclosure outline
            ctx.strokeStyle = '#4a9eff';
            ctx.lineWidth = 2;
            ctx.fillStyle = 'rgba(74, 158, 255, 0.1)';

            // Draw based on shape
            if (this.enclosure.shape === 'rounded_box' && this.enclosure.corner_radius > 0) {
                const r = this.enclosure.corner_radius * scale;
                this.roundRect(ctx, offsetX, offsetY, w, h, r);
            } else if (this.enclosure.shape === 'cylinder') {
                ctx.beginPath();
                ctx.ellipse(offsetX + w/2, offsetY + h/2, w/2, h/2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            } else {
                ctx.beginPath();
                ctx.rect(offsetX, offsetY, w, h);
                ctx.fill();
                ctx.stroke();
            }

            // Draw origin marker
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.beginPath();
            ctx.arc(offsetX, offsetY, 4, 0, Math.PI * 2);
            ctx.fill();

            // Draw axis labels
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '11px sans-serif';
            ctx.fillText('X â†’', offsetX + w/2 - 10, offsetY + h + 20);
            ctx.save();
            ctx.translate(offsetX - 20, offsetY + h/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('Y â†’', -10, 0);
            ctx.restore();

            // Draw components (sorted by selection - selected on top)
            const sortedComponents = [...this.projectComponents].sort((a, b) => {
                if (this.selectedComponent?.id === a.id) return 1;
                if (this.selectedComponent?.id === b.id) return -1;
                return 0;
            });

            for (const comp of sortedComponents) {
                this.drawComponent(ctx, comp, scale, offsetX, offsetY);
            }

            // Draw holes
            for (const hole of this.holes) {
                if (this.shouldDrawHole(hole)) {
                    const isSelected = this.selectedHole?.id === hole.id;
                    this.drawHole(ctx, hole, scale, offsetX, offsetY, isSelected);
                }
            }

            // Draw ghost hole preview in placement mode
            if (this.holePlacementMode && this.pendingHole) {
                this.drawGhostHole(ctx, scale, offsetX, offsetY);
            }

            // Draw drag hint if dragging
            if (this.isDragging && this.dragComponent) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = 'bold 11px sans-serif';
                const pos = this.dragComponent.position || { x_mm: 0, y_mm: 0 };
                ctx.fillText(`(${pos.x_mm.toFixed(1)}, ${pos.y_mm.toFixed(1)}) mm`, 10, canvas.height - 40);
            }

            // Draw drag hint if dragging hole
            if (this.isDraggingHole && this.dragHole) {
                ctx.fillStyle = 'rgba(255, 100, 100, 0.9)';
                ctx.font = 'bold 11px sans-serif';
                ctx.fillText(`Hole: (${this.dragHole.position_x_mm.toFixed(1)}, ${this.dragHole.position_y_mm.toFixed(1)}) mm`, 10, canvas.height - 40);
            }
        },

        drawGhostHole(ctx, scale, offsetX, offsetY) {
            const hx = offsetX + this.pendingHole.x * scale;
            const hy = offsetY + this.pendingHole.y * scale;
            const hw = this.holeForm.width * scale;
            const hh = this.holeForm.height * scale;

            // Dashed outline for ghost
            ctx.setLineDash([5, 5]);
            ctx.fillStyle = 'rgba(99, 102, 241, 0.3)';
            ctx.strokeStyle = '#6366f1';
            ctx.lineWidth = 2;

            ctx.beginPath();
            if (this.holeForm.circular) {
                ctx.arc(hx + hw/2, hy + hh/2, hw/2, 0, Math.PI * 2);
            } else {
                ctx.rect(hx, hy, hw, hh);
            }
            ctx.fill();
            ctx.stroke();
            ctx.setLineDash([]);

            // Position label
            ctx.fillStyle = '#a5b4fc';
            ctx.font = '10px sans-serif';
            ctx.fillText(`(${this.pendingHole.x.toFixed(1)}, ${this.pendingHole.y.toFixed(1)})`, hx, hy - 5);
        },

        drawGrid(ctx, scale, offsetX, offsetY, w, h) {
            const faceDims = this.getFaceDimensions();

            // Major grid lines (10mm)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 1;

            for (let x = 0; x <= faceDims.width; x += 10) {
                const sx = offsetX + x * scale;
                ctx.beginPath();
                ctx.moveTo(sx, offsetY);
                ctx.lineTo(sx, offsetY + h);
                ctx.stroke();
            }
            for (let y = 0; y <= faceDims.height; y += 10) {
                const sy = offsetY + y * scale;
                ctx.beginPath();
                ctx.moveTo(offsetX, sy);
                ctx.lineTo(offsetX + w, sy);
                ctx.stroke();
            }

            // Minor grid lines (5mm) when zoomed in enough
            if (this.zoom >= 0.75) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.07)';
                ctx.lineWidth = 0.5;
                for (let x = 5; x <= faceDims.width; x += 10) {
                    const sx = offsetX + x * scale;
                    ctx.beginPath();
                    ctx.moveTo(sx, offsetY);
                    ctx.lineTo(sx, offsetY + h);
                    ctx.stroke();
                }
                for (let y = 5; y <= faceDims.height; y += 10) {
                    const sy = offsetY + y * scale;
                    ctx.beginPath();
                    ctx.moveTo(offsetX, sy);
                    ctx.lineTo(offsetX + w, sy);
                    ctx.stroke();
                }
            }
        },

        roundRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        },

        drawComponent(ctx, comp, scale, offsetX, offsetY) {
            const isSelected = this.selectedComponent?.id === comp.id;
            const isDraggingThis = this.dragComponent?.id === comp.id;
            const isLocked = comp.locked;

            // Get actual dimensions
            const dims = this.componentDimensions[comp.component_id] || { length: 25, width: 18, height: 10 };

            // Get component position and size based on current face view
            let compX, compY, cw, ch;

            switch (this.currentFace) {
                case 'top':
                case 'bottom':
                    // Top/bottom view: X=x_mm, Y=y_mm, size=length x width
                    compX = comp.position?.x_mm || 0;
                    compY = comp.position?.y_mm || 0;
                    cw = dims.length;
                    ch = dims.width;
                    break;
                case 'front':
                case 'back':
                    // Front/back view: X=x_mm, Y=z_mm, size=length x height
                    compX = comp.position?.x_mm || 0;
                    compY = comp.position?.z_mm || 0;
                    cw = dims.length;
                    ch = dims.height;
                    break;
                case 'left':
                case 'right':
                    // Left/right view: X=y_mm, Y=z_mm, size=width x height
                    compX = comp.position?.y_mm || 0;
                    compY = comp.position?.z_mm || 0;
                    cw = dims.width;
                    ch = dims.height;
                    break;
                default:
                    compX = comp.position?.x_mm || 0;
                    compY = comp.position?.y_mm || 0;
                    cw = dims.length;
                    ch = dims.width;
            }

            const cx = offsetX + compX * scale;
            const cy = offsetY + compY * scale;
            cw = cw * scale;
            ch = ch * scale;

            // Shadow for selected/dragging component
            if (isSelected || isDraggingThis) {
                ctx.shadowColor = isSelected ? '#22c55e' : '#4a9eff';
                ctx.shadowBlur = 10;
            }

            // Component fill - locked components have muted appearance
            if (isLocked) {
                ctx.fillStyle = 'rgba(148, 163, 184, 0.2)';
                ctx.strokeStyle = '#64748b';
                ctx.setLineDash([4, 4]);  // Dashed line for locked
            } else if (isDraggingThis) {
                ctx.fillStyle = 'rgba(74, 158, 255, 0.4)';
                ctx.strokeStyle = '#4a9eff';
            } else if (isSelected) {
                ctx.fillStyle = 'rgba(34, 197, 94, 0.3)';
                ctx.strokeStyle = '#22c55e';
            } else {
                ctx.fillStyle = 'rgba(255, 200, 100, 0.3)';
                ctx.strokeStyle = '#ffc864';
            }
            ctx.lineWidth = isSelected ? 3 : 2;

            ctx.beginPath();
            ctx.rect(cx, cy, cw, ch);
            ctx.fill();
            ctx.stroke();

            // Reset line dash after drawing
            ctx.setLineDash([]);
            ctx.shadowBlur = 0;

            // Draw lock icon for locked components
            if (isLocked && this.zoom >= 0.5) {
                ctx.fillStyle = '#f59e0b';
                ctx.font = '10px sans-serif';
                ctx.fillText('ðŸ”’', cx + cw - 14, cy + 12);
            }

            // Draw component name
            ctx.fillStyle = isLocked ? '#94a3b8' : '#fff';
            ctx.font = `${isSelected ? 'bold ' : ''}${Math.max(9, Math.min(12, 10 * this.zoom))}px sans-serif`;

            // Truncate name if too long
            let name = comp.component_name || 'Component';
            const maxTextWidth = cw - 4;
            while (ctx.measureText(name).width > maxTextWidth && name.length > 3) {
                name = name.slice(0, -4) + '...';
            }

            ctx.fillText(name, cx + 3, cy + 13);

            // Draw dimensions on hover/select
            if (isSelected && this.zoom >= 0.75) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = '9px sans-serif';
                ctx.fillText(`${dims.length}Ã—${dims.width}mm`, cx + 3, cy + ch - 4);
            }

            // Draw feature indicators (small circles for enabled features)
            if (this.viewMode === 'top' && comp.enabled_features) {
                const enabledFeatures = comp.enabled_features.filter(f => f.enabled);
                enabledFeatures.forEach((feat, i) => {
                    const fx = cx + cw - 6 - (i * 8);
                    const fy = cy + 6;
                    ctx.beginPath();
                    ctx.arc(fx, fy, 3, 0, Math.PI * 2);
                    ctx.fillStyle = feat.hole_placed ? '#22c55e' : '#f59e0b';
                    ctx.fill();
                });
            }
        },

        drawHole(ctx, hole, scale, offsetX, offsetY, isSelected = false) {
            const hx = offsetX + (hole.position_x_mm || 0) * scale;
            const hy = offsetY + (hole.position_y_mm || 0) * scale;
            const hw = (hole.width_mm || 10) * scale;
            const hh = (hole.height_mm || 10) * scale;

            // Hole fill with pattern - highlight if selected
            if (isSelected) {
                ctx.shadowColor = '#ff6464';
                ctx.shadowBlur = 10;
                ctx.fillStyle = 'rgba(255, 100, 100, 0.6)';
                ctx.strokeStyle = '#ff9999';
                ctx.lineWidth = 3;
            } else {
                ctx.fillStyle = 'rgba(255, 100, 100, 0.4)';
                ctx.strokeStyle = '#ff6464';
                ctx.lineWidth = 2;
            }

            ctx.beginPath();
            if (hole.is_circular) {
                ctx.arc(hx + hw/2, hy + hh/2, hw/2, 0, Math.PI * 2);
            } else {
                ctx.rect(hx, hy, hw, hh);
            }
            ctx.fill();
            ctx.stroke();

            ctx.shadowBlur = 0;

            // Draw hole label if zoomed enough
            if (this.zoom >= 0.75) {
                ctx.fillStyle = isSelected ? '#ffcccc' : '#ff9999';
                ctx.font = isSelected ? 'bold 9px sans-serif' : '8px sans-serif';
                ctx.fillText(hole.name || 'Hole', hx + 2, hy + hh + 10);
            }
        },

        shouldDrawHole(hole) {
            // Only show holes on the currently selected face
            return hole.face === this.currentFace;
        },

        setViewMode(mode) {
            const previousMode = this.viewMode;
            this.viewMode = mode;

            if (mode === '3d') {
                // Initialize or update 3D preview
                this.init3DPreview();
            } else {
                // Switching back to 2D view
                const canvas = document.getElementById('enclosure-canvas');
                if (canvas) {
                    // Need to wait for canvas to be visible
                    this.$nextTick(() => {
                        this.resizeCanvas(canvas);
                        this.drawEnclosure(canvas.getContext('2d'), canvas);
                    });
                }
            }
        },

        init3DPreview() {
            if (!this.preview3D) {
                this.preview3D = new EnclosurePreview3D('three-preview-container');
                this.preview3D.init();
            }
            this.update3DPreview();
        },

        update3DPreview() {
            if (!this.preview3D) return;

            this.preview3D.update({
                enclosure: this.enclosure,
                components: this.projectComponents,
                holes: this.holes,
                componentDimensions: this.componentDimensions,
                selectedComponentId: this.selectedComponent?.id
            });
        },

        toggle3DLid() {
            this.show3DLid = !this.show3DLid;
            if (this.preview3D) {
                this.preview3D.setShowLid(this.show3DLid);
            }
        },

        toggleExplodedView() {
            this.exploded3DView = !this.exploded3DView;
            if (this.preview3D) {
                this.preview3D.setExplodedView(this.exploded3DView);
            }
        },

        reset3DView() {
            if (this.preview3D) {
                this.preview3D.resetView();
            }
        },

        selectComponent(comp) {
            this.selectedComponent = comp;
            this.rightTab = 'features';

            if (this.viewMode === '3d') {
                this.update3DPreview();
            } else {
                const canvas = document.getElementById('enclosure-canvas');
                if (canvas) {
                    this.drawEnclosure(canvas.getContext('2d'), canvas);
                }
            }
        },

        async addComponent(componentId, componentName) {
            const response = await fetch(`/projects/api/${PROJECT_ID}/components`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ component_id: componentId })
            });

            if (response.ok) {
                const data = await response.json();
                this.projectComponents.push(data.component);
                this.leftTab = 'project';
                this.selectComponent(data.component);
            }
        },

        async removeComponent(componentId) {
            const response = await fetch(`/projects/api/${PROJECT_ID}/components/${componentId}`, {
                method: 'DELETE'
            });

            if (response.ok) {
                this.projectComponents = this.projectComponents.filter(c => c.id !== componentId);
                if (this.selectedComponent?.id === componentId) {
                    this.selectedComponent = null;
                }
            }
        },

        async toggleFeature(componentId, featureId, enabled) {
            const features = {};
            features[featureId] = enabled;

            const response = await fetch(`/projects/api/${PROJECT_ID}/components/${componentId}/features`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ features })
            });

            if (response.ok) {
                // Update local state
                const comp = this.projectComponents.find(c => c.id === componentId);
                if (comp) {
                    const feat = comp.enabled_features.find(f => f.feature_id === featureId);
                    if (feat) {
                        feat.enabled = enabled;
                    }
                }
            }
        },

        placeHoleForFeature(feat) {
            // Use inline form instead of modal
            // Pre-fill with feature's suggested values
            this.holeForm = {
                show: true,
                isEditing: false,
                editingHoleId: null,
                name: feat.feature_name,
                face: feat.required_face || 'front',
                x: 10,
                y: 10,
                width: feat.hole_width_mm || 10,
                height: feat.hole_height_mm || 10,
                circular: feat.is_circular || false,
                componentId: this.selectedComponent?.id,
                featureId: feat.feature_id
            };
            this.rightTab = 'holes';
            // Switch canvas to show the feature's suggested face for placement
            this.currentFace = feat.required_face || 'front';
            this.onFaceChange();
        },

        async removeHole(holeId) {
            const response = await fetch(`/projects/api/${PROJECT_ID}/holes/${holeId}`, {
                method: 'DELETE'
            });

            if (response.ok) {
                this.holes = this.holes.filter(h => h.id !== holeId);

                // Update feature state
                for (const comp of this.projectComponents) {
                    for (const feat of comp.enabled_features || []) {
                        if (feat.hole_id === holeId) {
                            feat.hole_placed = false;
                            feat.hole_id = null;
                        }
                    }
                }

                // Redraw canvas or update 3D preview
                if (this.viewMode === '3d') {
                    this.update3DPreview();
                } else {
                    const canvas = document.getElementById('enclosure-canvas');
                    if (canvas) {
                        this.drawEnclosure(canvas.getContext('2d'), canvas);
                    }
                }
            }
        },

        async updateEnclosure() {
            await fetch(`/projects/api/${PROJECT_ID}/enclosure`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    dimensions: {
                        inner_length_mm: this.enclosure.inner_length,
                        inner_width_mm: this.enclosure.inner_width,
                        inner_height_mm: this.enclosure.inner_height
                    },
                    wall_thickness_mm: this.enclosure.wall_thickness,
                    bottom_thickness_mm: this.enclosure.bottom_thickness,
                    corner_radius_mm: this.enclosure.corner_radius,
                    shape: this.enclosure.shape,
                    lid: { type: this.enclosure.lid_type }
                })
            });

            // Redraw canvas or update 3D preview
            if (this.viewMode === '3d') {
                this.update3DPreview();
            } else {
                const canvas = document.getElementById('enclosure-canvas');
                if (canvas) {
                    this.drawEnclosure(canvas.getContext('2d'), canvas);
                }
            }
        },

        autoSizeEnclosure() {
            // Calculate size based on components
            let maxX = 50, maxY = 30;
            for (const comp of this.projectComponents) {
                maxX = Math.max(maxX, (comp.position?.x_mm || 0) + 30);
                maxY = Math.max(maxY, (comp.position?.y_mm || 0) + 20);
            }
            this.enclosure.inner_length = Math.ceil(maxX + 10);
            this.enclosure.inner_width = Math.ceil(maxY + 10);
            this.updateEnclosure();
        },

        async autoSuggestHoles() {
            const response = await fetch(`/projects/api/${PROJECT_ID}/suggest-holes`);
            if (response.ok) {
                const data = await response.json();
                // Would show suggestions to user
                alert(`Found ${data.suggestions.length} suggested hole placements. Auto-placement coming soon!`);
            }
        },

        addVentilation() {
            // Reset to defaults
            this.ventModal = {
                pattern: 'grid',
                face: 'top',
                x: 10,
                y: 10,
                zoneWidth: 40,
                zoneHeight: 30,
                holeDiameter: 3,
                spacing: 5,
                slotWidth: 2,
                slotLength: 15,
                slotSpacing: 4,
                cornerRadius: 1,
                louverWidth: 3,
                louverAngle: 45,
                louverCount: 5
            };
            this.showVentModal = true;

            // Draw preview after modal is visible
            this.$nextTick(() => this.drawVentPreview());
        },

        drawVentPreview() {
            const canvas = document.getElementById('vent-preview-canvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            // Clear
            ctx.fillStyle = '#2a2a4e';
            ctx.fillRect(0, 0, w, h);

            // Scale to fit
            const scale = Math.min((w - 20) / this.ventModal.zoneWidth, (h - 20) / this.ventModal.zoneHeight);
            const offsetX = (w - this.ventModal.zoneWidth * scale) / 2;
            const offsetY = (h - this.ventModal.zoneHeight * scale) / 2;

            // Draw zone boundary
            ctx.strokeStyle = 'rgba(74, 158, 255, 0.5)';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.strokeRect(offsetX, offsetY, this.ventModal.zoneWidth * scale, this.ventModal.zoneHeight * scale);
            ctx.setLineDash([]);

            // Draw pattern preview
            ctx.fillStyle = 'rgba(255, 100, 100, 0.6)';
            ctx.strokeStyle = '#ff6464';
            ctx.lineWidth = 1;

            const pattern = this.ventModal.pattern;

            if (pattern === 'grid') {
                const d = this.ventModal.holeDiameter * scale;
                const spacing = this.ventModal.spacing * scale;
                const cols = Math.floor(this.ventModal.zoneWidth / this.ventModal.spacing);
                const rows = Math.floor(this.ventModal.zoneHeight / this.ventModal.spacing);

                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const cx = offsetX + (col + 0.5) * spacing;
                        const cy = offsetY + (row + 0.5) * spacing;
                        ctx.beginPath();
                        ctx.arc(cx, cy, d / 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    }
                }
            } else if (pattern === 'honeycomb') {
                const d = this.ventModal.holeDiameter * scale;
                const spacing = this.ventModal.spacing * scale;
                const cols = Math.floor(this.ventModal.zoneWidth / this.ventModal.spacing);
                const rows = Math.floor(this.ventModal.zoneHeight / (this.ventModal.spacing * 0.866));

                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const offset = (row % 2) * spacing * 0.5;
                        const cx = offsetX + col * spacing + offset + spacing / 2;
                        const cy = offsetY + row * spacing * 0.866 + spacing / 2;
                        if (cx < offsetX + this.ventModal.zoneWidth * scale && cy < offsetY + this.ventModal.zoneHeight * scale) {
                            ctx.beginPath();
                            ctx.arc(cx, cy, d / 2, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.stroke();
                        }
                    }
                }
            } else if (pattern === 'slots_horizontal' || pattern === 'slots_vertical') {
                const slotW = (pattern === 'slots_horizontal' ? this.ventModal.slotLength : this.ventModal.slotWidth) * scale;
                const slotH = (pattern === 'slots_horizontal' ? this.ventModal.slotWidth : this.ventModal.slotLength) * scale;
                const spacing = this.ventModal.slotSpacing * scale;
                const r = this.ventModal.cornerRadius * scale;

                const count = pattern === 'slots_horizontal'
                    ? Math.floor(this.ventModal.zoneHeight / (this.ventModal.slotWidth + this.ventModal.slotSpacing))
                    : Math.floor(this.ventModal.zoneWidth / (this.ventModal.slotWidth + this.ventModal.slotSpacing));

                for (let i = 0; i < count; i++) {
                    let sx, sy;
                    if (pattern === 'slots_horizontal') {
                        sx = offsetX + (this.ventModal.zoneWidth * scale - slotW) / 2;
                        sy = offsetY + i * (slotH + spacing) + spacing / 2;
                    } else {
                        sx = offsetX + i * (slotW + spacing) + spacing / 2;
                        sy = offsetY + (this.ventModal.zoneHeight * scale - slotH) / 2;
                    }
                    ctx.beginPath();
                    ctx.roundRect(sx, sy, slotW, slotH, r);
                    ctx.fill();
                    ctx.stroke();
                }
            } else if (pattern === 'louvers') {
                const count = this.ventModal.louverCount;
                const zoneH = this.ventModal.zoneHeight * scale;
                const zoneW = this.ventModal.zoneWidth * scale;
                const louverW = this.ventModal.louverWidth * scale;
                const spacing = zoneH / (count + 1);

                for (let i = 0; i < count; i++) {
                    const y = offsetY + (i + 1) * spacing;
                    ctx.beginPath();
                    ctx.moveTo(offsetX + 5, y - louverW / 2);
                    ctx.lineTo(offsetX + zoneW - 5, y - louverW / 2);
                    ctx.lineTo(offsetX + zoneW - 5, y + louverW / 2);
                    ctx.lineTo(offsetX + 5, y + louverW / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
            }
        },

        calculateVentHoleCount() {
            const pattern = this.ventModal.pattern;

            if (pattern === 'grid') {
                const cols = Math.floor(this.ventModal.zoneWidth / this.ventModal.spacing);
                const rows = Math.floor(this.ventModal.zoneHeight / this.ventModal.spacing);
                return cols * rows;
            } else if (pattern === 'honeycomb') {
                const cols = Math.floor(this.ventModal.zoneWidth / this.ventModal.spacing);
                const rows = Math.floor(this.ventModal.zoneHeight / (this.ventModal.spacing * 0.866));
                return Math.floor(cols * rows * 0.9); // Approximate
            } else if (pattern === 'slots_horizontal') {
                return Math.floor(this.ventModal.zoneHeight / (this.ventModal.slotWidth + this.ventModal.slotSpacing));
            } else if (pattern === 'slots_vertical') {
                return Math.floor(this.ventModal.zoneWidth / (this.ventModal.slotWidth + this.ventModal.slotSpacing));
            } else if (pattern === 'louvers') {
                return this.ventModal.louverCount;
            }
            return 0;
        },

        calculateOpenArea() {
            const pattern = this.ventModal.pattern;
            const zoneArea = this.ventModal.zoneWidth * this.ventModal.zoneHeight;

            let openArea = 0;
            if (pattern === 'grid') {
                const holeArea = Math.PI * Math.pow(this.ventModal.holeDiameter / 2, 2);
                openArea = holeArea * this.calculateVentHoleCount();
            } else if (pattern === 'honeycomb') {
                const holeArea = Math.PI * Math.pow(this.ventModal.holeDiameter / 2, 2);
                openArea = holeArea * this.calculateVentHoleCount();
            } else if (pattern === 'slots_horizontal' || pattern === 'slots_vertical') {
                const slotArea = this.ventModal.slotWidth * this.ventModal.slotLength;
                openArea = slotArea * this.calculateVentHoleCount();
            } else if (pattern === 'louvers') {
                // Approximate - louvers have angled openings
                openArea = zoneArea * 0.4;
            }

            return Math.round((openArea / zoneArea) * 100);
        },

        async confirmVentilation() {
            // Add ventilation zone to the project
            const ventZone = {
                id: 'vent-' + Date.now(),
                name: `${this.ventModal.pattern.replace('_', ' ')} Ventilation`,
                pattern: this.ventModal.pattern,
                face: this.ventModal.face,
                position_x_mm: this.ventModal.x,
                position_y_mm: this.ventModal.y,
                zone_width_mm: this.ventModal.zoneWidth,
                zone_height_mm: this.ventModal.zoneHeight,
                settings: { ...this.ventModal }
            };

            this.ventilationZones.push(ventZone);

            // Also add as a special hole entry for OpenSCAD generation
            const response = await fetch(`/projects/api/${PROJECT_ID}/holes`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: ventZone.name,
                    face: this.ventModal.face,
                    x: this.ventModal.x,
                    y: this.ventModal.y,
                    width: this.ventModal.zoneWidth,
                    height: this.ventModal.zoneHeight,
                    is_circular: false,
                    hole_type: 'ventilation',
                    ventilation_pattern: this.ventModal.pattern,
                    ventilation_settings: { ...this.ventModal }
                })
            });

            if (response.ok) {
                const data = await response.json();
                this.holes.push(data.hole);
            }

            this.showVentModal = false;

            // Refresh canvas/3D
            if (this.viewMode === '3d') {
                this.update3DPreview();
            } else {
                this.redrawCanvas();
            }
        },

        selectHole(hole) {
            // Highlight hole, show properties
        },

        searchComponents() {
            // HTMX handles this via the search input
        }
    };
}
</script>
{% endblock %}
