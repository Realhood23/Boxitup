"""OpenSCAD script generation service."""
from app.models.project import Project
from app.models.enclosure import Enclosure, EnclosureShape, LidType, VentPattern


class OpenSCADService:
    """
    Service for generating OpenSCAD scripts from project configurations.

    Generates parametric, well-commented scripts that users can further
    customize in OpenSCAD.
    """

    def generate_script(self, project: Project) -> str:
        """
        Generate complete OpenSCAD script for an enclosure.

        Args:
            project: The project to generate script for

        Returns:
            OpenSCAD script as string
        """
        if not project.enclosure_config:
            raise ValueError("Project has no enclosure configuration")

        enclosure = Enclosure.from_dict(project.enclosure_config)

        parts = [
            self._generate_header(project),
            self._generate_parameters(enclosure),
            self._generate_modules(enclosure),
            self._generate_hole_modules(enclosure),
            self._generate_vent_modules(enclosure),
            self._generate_lid_modules(enclosure),
            self._generate_standoff_modules(enclosure),
            self._generate_main_body(enclosure),
            self._generate_lid(enclosure),
            self._generate_assembly(enclosure)
        ]

        return '\n\n'.join(filter(None, parts))

    def generate_lid_script(self, project: Project) -> str:
        """Generate just the lid as a separate file."""
        if not project.enclosure_config:
            raise ValueError("Project has no enclosure configuration")

        enclosure = Enclosure.from_dict(project.enclosure_config)

        parts = [
            self._generate_header(project, lid_only=True),
            self._generate_parameters(enclosure),
            self._generate_lid_modules(enclosure),
            '// Render the lid\nlid();'
        ]

        return '\n\n'.join(filter(None, parts))

    def _generate_header(self, project: Project, lid_only: bool = False) -> str:
        """Generate script header with comments."""
        component = "Lid" if lid_only else "Enclosure"
        return f'''// ============================================
// {component} for: {project.name}
// Generated by Enclosure Generator
// ============================================
//
// Description: {project.description}
//
// Instructions:
// 1. Open this file in OpenSCAD
// 2. Press F5 to preview or F6 to render
// 3. Adjust parameters below as needed
// 4. Export as STL for 3D printing
//
// Tip: Use the Customizer panel (View > Customizer)
// to interactively adjust parameters.
//
// ============================================

$fn = 50; // Curve resolution (increase for smoother curves)
'''

    def _generate_parameters(self, enclosure: Enclosure) -> str:
        """Generate customizable parameters section."""
        outer = enclosure.get_outer_dimensions()

        return f'''// ============================================
// PARAMETERS - Adjust these values
// ============================================

/* [Enclosure Dimensions] */
// Inner length (X)
inner_length = {enclosure.inner_length_mm};
// Inner width (Y)
inner_width = {enclosure.inner_width_mm};
// Inner height (Z)
inner_height = {enclosure.inner_height_mm};

/* [Wall Settings] */
// Wall thickness
wall_thickness = {enclosure.wall_thickness_mm};
// Bottom thickness
bottom_thickness = {enclosure.bottom_thickness_mm};
// Corner radius (0 for sharp corners)
corner_radius = {enclosure.corner_radius_mm};

/* [Lid Settings] */
// Lid thickness
lid_thickness = {enclosure.lid_thickness_mm};
// Lid clearance (gap for fit)
lid_clearance = {enclosure.lid_clearance_mm};
// Lid overlap (how much lid overlaps walls)
lid_overlap = {enclosure.lid_overlap_mm};

/* [Calculated Values] */
// Outer dimensions (calculated)
outer_length = inner_length + 2 * wall_thickness;
outer_width = inner_width + 2 * wall_thickness;
outer_height = inner_height + bottom_thickness;

/* [Print Settings] */
// Printer tolerance (adjust for your printer)
printer_tolerance = 0.2;
'''

    def _generate_modules(self, enclosure: Enclosure) -> str:
        """Generate basic shape modules."""
        if enclosure.shape == EnclosureShape.ROUNDED_BOX:
            return self._generate_rounded_box_module()
        elif enclosure.shape == EnclosureShape.CYLINDER:
            return self._generate_cylinder_module()
        elif enclosure.shape == EnclosureShape.HEXAGON:
            return self._generate_hexagon_module()
        else:
            return self._generate_basic_box_module()

    def _generate_basic_box_module(self) -> str:
        """Generate basic rectangular box module."""
        return '''// ============================================
// SHAPE MODULES
// ============================================

// Basic box shape
module box_shape(length, width, height, wall, bottom, radius=0) {
    if (radius > 0) {
        // Rounded corners
        minkowski() {
            cube([length - 2*radius, width - 2*radius, height/2]);
            cylinder(r=radius, h=height/2);
        }
    } else {
        // Sharp corners
        cube([length, width, height]);
    }
}

// Hollow box (shell)
module hollow_box(length, width, height, wall, bottom, radius=0) {
    difference() {
        // Outer shell
        box_shape(length, width, height, wall, bottom, radius);

        // Inner cavity
        translate([wall, wall, bottom])
            box_shape(
                length - 2*wall,
                width - 2*wall,
                height,
                wall,
                bottom,
                max(0, radius - wall)
            );
    }
}
'''

    def _generate_rounded_box_module(self) -> str:
        """Generate rounded box module."""
        return '''// ============================================
// SHAPE MODULES - Rounded Box
// ============================================

// Rounded box shape using hull and cylinders
module rounded_box(length, width, height, radius) {
    hull() {
        // Four corner cylinders
        translate([radius, radius, 0])
            cylinder(r=radius, h=height);
        translate([length - radius, radius, 0])
            cylinder(r=radius, h=height);
        translate([radius, width - radius, 0])
            cylinder(r=radius, h=height);
        translate([length - radius, width - radius, 0])
            cylinder(r=radius, h=height);
    }
}

// Hollow rounded box
module hollow_box(length, width, height, wall, bottom, radius) {
    difference() {
        // Outer shell
        rounded_box(length, width, height, radius);

        // Inner cavity
        translate([wall, wall, bottom])
            rounded_box(
                length - 2*wall,
                width - 2*wall,
                height,
                max(1, radius - wall)
            );
    }
}
'''

    def _generate_cylinder_module(self) -> str:
        """Generate cylindrical enclosure module."""
        return '''// ============================================
// SHAPE MODULES - Cylinder
// ============================================

// Cylindrical enclosure
module cylinder_enclosure(diameter, height, wall, bottom) {
    difference() {
        cylinder(d=diameter, h=height);
        translate([0, 0, bottom])
            cylinder(d=diameter - 2*wall, h=height);
    }
}

// Alias for compatibility
module hollow_box(length, width, height, wall, bottom, radius=0) {
    diameter = max(length, width);
    translate([diameter/2, diameter/2, 0])
        cylinder_enclosure(diameter, height, wall, bottom);
}
'''

    def _generate_hexagon_module(self) -> str:
        """Generate hexagonal enclosure module."""
        return '''// ============================================
// SHAPE MODULES - Hexagon
// ============================================

// Hexagonal prism
module hexagon(size, height) {
    cylinder(d=size, h=height, $fn=6);
}

// Hollow hexagonal enclosure
module hollow_box(length, width, height, wall, bottom, radius=0) {
    size = max(length, width);
    difference() {
        translate([size/2, size/2, 0])
            hexagon(size, height);
        translate([size/2, size/2, bottom])
            hexagon(size - 2*wall, height);
    }
}
'''

    def _generate_hole_modules(self, enclosure: Enclosure) -> str:
        """Generate modules for all holes/cutouts."""
        if not enclosure.holes:
            return ''

        parts = ['// ============================================',
                 '// HOLE/CUTOUT MODULES',
                 '// ============================================']

        for i, hole in enumerate(enclosure.holes):
            hole_code = self._generate_single_hole_module(hole, i)
            parts.append(hole_code)

        # Generate combined holes module
        parts.append('''
// All holes combined
module all_holes() {
''')
        for i, hole in enumerate(enclosure.holes):
            parts.append(f'    hole_{i}(); // {hole.name}')
        parts.append('}')

        return '\n'.join(parts)

    def _generate_single_hole_module(self, hole, index: int) -> str:
        """Generate module for a single hole."""
        face_transforms = {
            'front': f'translate([{hole.position_x_mm}, 0, {hole.position_y_mm}]) rotate([90, 0, 0])',
            'back': f'translate([{hole.position_x_mm}, outer_width, {hole.position_y_mm}]) rotate([-90, 0, 0])',
            'left': f'translate([0, {hole.position_x_mm}, {hole.position_y_mm}]) rotate([0, -90, 0])',
            'right': f'translate([outer_length, {hole.position_x_mm}, {hole.position_y_mm}]) rotate([0, 90, 0])',
            'top': f'translate([{hole.position_x_mm}, {hole.position_y_mm}, outer_height])',
            'bottom': f'translate([{hole.position_x_mm}, {hole.position_y_mm}, 0]) rotate([180, 0, 0])'
        }

        transform = face_transforms.get(hole.face, face_transforms['front'])

        if hole.is_circular:
            shape = f'cylinder(d={hole.width_mm}, h=wall_thickness * 3, center=true);'
        elif hole.corner_radius_mm > 0:
            shape = f'''hull() {{
            translate([{hole.corner_radius_mm}, {hole.corner_radius_mm}, 0])
                cylinder(r={hole.corner_radius_mm}, h=wall_thickness * 3, center=true);
            translate([{hole.width_mm - hole.corner_radius_mm}, {hole.corner_radius_mm}, 0])
                cylinder(r={hole.corner_radius_mm}, h=wall_thickness * 3, center=true);
            translate([{hole.corner_radius_mm}, {hole.height_mm - hole.corner_radius_mm}, 0])
                cylinder(r={hole.corner_radius_mm}, h=wall_thickness * 3, center=true);
            translate([{hole.width_mm - hole.corner_radius_mm}, {hole.height_mm - hole.corner_radius_mm}, 0])
                cylinder(r={hole.corner_radius_mm}, h=wall_thickness * 3, center=true);
        }}'''
        else:
            shape = f'cube([{hole.width_mm}, {hole.height_mm}, wall_thickness * 3], center=true);'

        return f'''
// Hole: {hole.name} ({hole.hole_type.value})
module hole_{index}() {{
    {transform}
        {shape}
}}
'''

    def _generate_vent_modules(self, enclosure: Enclosure) -> str:
        """Generate ventilation pattern modules."""
        if not enclosure.ventilation_zones:
            return ''

        parts = ['// ============================================',
                 '// VENTILATION MODULES',
                 '// ============================================']

        for i, vent in enumerate(enclosure.ventilation_zones):
            vent_code = self._generate_single_vent_module(vent, i)
            parts.append(vent_code)

        # Combined vents module
        parts.append('''
// All ventilation combined
module all_vents() {
''')
        for i, vent in enumerate(enclosure.ventilation_zones):
            parts.append(f'    vent_{i}(); // {vent.name}')
        parts.append('}')

        return '\n'.join(parts)

    def _generate_single_vent_module(self, vent, index: int) -> str:
        """Generate module for a ventilation zone."""
        face_transforms = {
            'front': f'translate([{vent.position_x_mm}, 0, {vent.position_y_mm}])',
            'back': f'translate([{vent.position_x_mm}, outer_width - wall_thickness, {vent.position_y_mm}])',
            'left': f'translate([0, {vent.position_x_mm}, {vent.position_y_mm}])',
            'right': f'translate([outer_length - wall_thickness, {vent.position_x_mm}, {vent.position_y_mm}])',
            'top': f'translate([{vent.position_x_mm}, {vent.position_y_mm}, outer_height - lid_thickness])',
            'bottom': f'translate([{vent.position_x_mm}, {vent.position_y_mm}, 0])'
        }

        transform = face_transforms.get(vent.face, face_transforms['top'])

        if vent.pattern == VentPattern.GRID:
            pattern = self._generate_grid_vent_pattern(vent)
        elif vent.pattern == VentPattern.SLOTS:
            pattern = self._generate_slots_vent_pattern(vent)
        elif vent.pattern == VentPattern.HONEYCOMB:
            pattern = self._generate_honeycomb_vent_pattern(vent)
        else:
            pattern = self._generate_grid_vent_pattern(vent)

        return f'''
// Ventilation: {vent.name} ({vent.pattern.value} pattern)
module vent_{index}() {{
    {transform}
    {pattern}
}}
'''

    def _generate_grid_vent_pattern(self, vent) -> str:
        """Generate grid pattern of circular holes."""
        return f'''    // Grid ventilation pattern
    for (x = [0 : {vent.hole_spacing_mm} : {vent.width_mm}]) {{
        for (y = [0 : {vent.hole_spacing_mm} : {vent.height_mm}]) {{
            translate([x, y, 0])
                cylinder(d={vent.hole_diameter_mm}, h=wall_thickness * 3, center=true);
        }}
    }}'''

    def _generate_slots_vent_pattern(self, vent) -> str:
        """Generate parallel slots pattern."""
        return f'''    // Slot ventilation pattern
    for (y = [0 : {vent.hole_spacing_mm} : {vent.height_mm}]) {{
        translate([0, y, 0])
            cube([{vent.slot_length_mm}, {vent.slot_width_mm}, wall_thickness * 3], center=true);
    }}'''

    def _generate_honeycomb_vent_pattern(self, vent) -> str:
        """Generate honeycomb pattern of hexagonal holes."""
        return f'''    // Honeycomb ventilation pattern
    hex_spacing = {vent.hole_spacing_mm};
    for (row = [0 : 1 : floor({vent.height_mm} / (hex_spacing * 0.866))]) {{
        offset = (row % 2) * hex_spacing / 2;
        for (col = [0 : 1 : floor({vent.width_mm} / hex_spacing)]) {{
            translate([col * hex_spacing + offset, row * hex_spacing * 0.866, 0])
                cylinder(d={vent.hole_diameter_mm}, h=wall_thickness * 3, $fn=6, center=true);
        }}
    }}'''

    def _generate_lid_modules(self, enclosure: Enclosure) -> str:
        """Generate lid-related modules."""
        if enclosure.lid_type == LidType.NONE:
            return ''

        if enclosure.lid_type == LidType.SNAP_FIT:
            return self._generate_snap_fit_lid()
        elif enclosure.lid_type == LidType.SCREW_MOUNT:
            return self._generate_screw_mount_lid(enclosure)
        elif enclosure.lid_type == LidType.SLIDING:
            return self._generate_sliding_lid()
        elif enclosure.lid_type == LidType.PRESS_FIT:
            return self._generate_press_fit_lid()
        else:
            return self._generate_snap_fit_lid()

    def _generate_snap_fit_lid(self) -> str:
        """Generate snap-fit lid module."""
        return '''// ============================================
// LID MODULES - Snap Fit
// ============================================

// Snap-fit clip
module snap_clip(height=3, width=2, depth=1) {
    // Flexible clip that snaps into groove
    hull() {
        cube([width, depth, height - 1]);
        translate([0, depth/2, height])
            rotate([0, 90, 0])
                cylinder(d=depth, h=width, $fn=20);
    }
}

// Snap-fit groove (cut into body)
module snap_groove(height=3, width=2.5, depth=1.5) {
    cube([width, depth, height]);
}

// Lid with snap-fit clips
module lid() {
    difference() {
        union() {
            // Main lid plate
            cube([outer_length, outer_width, lid_thickness]);

            // Inner lip that fits inside the box
            translate([wall_thickness + lid_clearance, wall_thickness + lid_clearance, -lid_overlap])
                cube([
                    outer_length - 2*(wall_thickness + lid_clearance),
                    outer_width - 2*(wall_thickness + lid_clearance),
                    lid_overlap
                ]);

            // Snap clips on the lip
            clip_offset = 10;
            // Front clips
            translate([clip_offset, wall_thickness + lid_clearance, -lid_overlap])
                rotate([0, 0, -90])
                    snap_clip();
            translate([outer_length - clip_offset - 2, wall_thickness + lid_clearance, -lid_overlap])
                rotate([0, 0, -90])
                    snap_clip();
            // Back clips
            translate([clip_offset, outer_width - wall_thickness - lid_clearance, -lid_overlap])
                rotate([0, 0, 90])
                    snap_clip();
            translate([outer_length - clip_offset - 2, outer_width - wall_thickness - lid_clearance, -lid_overlap])
                rotate([0, 0, 90])
                    snap_clip();
        }

        // Holes in lid (if any on top face)
        // ... will be added by all_holes() intersection
    }
}

// Grooves to cut into body for snap clips
module lid_grooves() {
    clip_offset = 10;
    groove_z = outer_height - 3;

    // Front grooves
    translate([clip_offset, wall_thickness - 0.5, groove_z])
        snap_groove();
    translate([outer_length - clip_offset - 2.5, wall_thickness - 0.5, groove_z])
        snap_groove();
    // Back grooves
    translate([clip_offset, outer_width - wall_thickness - 1, groove_z])
        snap_groove();
    translate([outer_length - clip_offset - 2.5, outer_width - wall_thickness - 1, groove_z])
        snap_groove();
}
'''

    def _generate_screw_mount_lid(self, enclosure: Enclosure) -> str:
        """Generate screw-mount lid module."""
        screw_d = enclosure.lid_screw_diameter_mm

        return f'''// ============================================
// LID MODULES - Screw Mount
// ============================================

screw_diameter = {screw_d};
screw_head_diameter = {screw_d * 2};
screw_head_depth = 2;

// Screw boss (pillar for screw)
module screw_boss(height, outer_d, inner_d) {{
    difference() {{
        cylinder(d=outer_d, h=height);
        translate([0, 0, -0.1])
            cylinder(d=inner_d, h=height + 0.2);
    }}
}}

// Lid with screw holes
module lid() {{
    difference() {{
        union() {{
            // Main lid plate
            cube([outer_length, outer_width, lid_thickness]);

            // Inner lip
            translate([wall_thickness + lid_clearance, wall_thickness + lid_clearance, -lid_overlap])
                cube([
                    outer_length - 2*(wall_thickness + lid_clearance),
                    outer_width - 2*(wall_thickness + lid_clearance),
                    lid_overlap
                ]);
        }}

        // Screw holes in corners
        corner_offset = 5;
        positions = [
            [corner_offset, corner_offset],
            [outer_length - corner_offset, corner_offset],
            [corner_offset, outer_width - corner_offset],
            [outer_length - corner_offset, outer_width - corner_offset]
        ];

        for (pos = positions) {{
            translate([pos[0], pos[1], -0.1]) {{
                // Through hole
                cylinder(d=screw_diameter, h=lid_thickness + 0.2);
                // Countersink
                translate([0, 0, lid_thickness - screw_head_depth])
                    cylinder(d1=screw_diameter, d2=screw_head_diameter, h=screw_head_depth + 0.1);
            }}
        }}
    }}
}}

// Screw bosses for body
module screw_bosses() {{
    corner_offset = 5;
    boss_height = inner_height - 2;

    positions = [
        [corner_offset, corner_offset],
        [outer_length - corner_offset, corner_offset],
        [corner_offset, outer_width - corner_offset],
        [outer_length - corner_offset, outer_width - corner_offset]
    ];

    for (pos = positions) {{
        translate([pos[0], pos[1], bottom_thickness])
            screw_boss(boss_height, screw_diameter * 2.5, screw_diameter * 0.8);
    }}
}}
'''

    def _generate_sliding_lid(self) -> str:
        """Generate sliding lid module."""
        return '''// ============================================
// LID MODULES - Sliding
// ============================================

slide_groove_depth = 2;
slide_groove_width = lid_thickness + 0.4;

// Sliding lid
module lid() {
    // Lid plate with rails
    cube([outer_length + 10, outer_width - 2*wall_thickness - 2*lid_clearance, lid_thickness]);
}

// Grooves for sliding lid (cut into body walls)
module slide_grooves() {
    // Left groove
    translate([-0.1, wall_thickness, outer_height - slide_groove_depth])
        cube([wall_thickness + 0.2, slide_groove_width, slide_groove_depth + 0.1]);

    // Right groove
    translate([outer_length - wall_thickness - 0.1, wall_thickness, outer_height - slide_groove_depth])
        cube([wall_thickness + 0.2, slide_groove_width, slide_groove_depth + 0.1]);
}
'''

    def _generate_press_fit_lid(self) -> str:
        """Generate press-fit lid module."""
        return '''// ============================================
// LID MODULES - Press Fit
// ============================================

// Simple press-fit lid
module lid() {
    union() {
        // Main lid plate
        cube([outer_length, outer_width, lid_thickness]);

        // Inner lip that press-fits into the box
        translate([wall_thickness + lid_clearance, wall_thickness + lid_clearance, -lid_overlap])
            cube([
                outer_length - 2*(wall_thickness + lid_clearance),
                outer_width - 2*(wall_thickness + lid_clearance),
                lid_overlap
            ]);
    }
}
'''

    def _generate_standoff_modules(self, enclosure: Enclosure) -> str:
        """Generate standoff modules for mounting components."""
        if not enclosure.standoff_positions:
            return ''

        positions_str = ',\n        '.join([
            f'[{s["x"]}, {s["y"]}, {s.get("height", 5)}, {s.get("diameter", 5)}]'
            for s in enclosure.standoff_positions
        ])

        return f'''// ============================================
// STANDOFF MODULES
// ============================================

// Component mounting standoff
module standoff(height, outer_d, inner_d=2.5) {{
    difference() {{
        cylinder(d=outer_d, h=height);
        translate([0, 0, -0.1])
            cylinder(d=inner_d, h=height + 0.2);
    }}
}}

// All standoffs
module all_standoffs() {{
    // Format: [x, y, height, diameter]
    standoff_positions = [
        {positions_str}
    ];

    for (pos = standoff_positions) {{
        translate([wall_thickness + pos[0], wall_thickness + pos[1], bottom_thickness])
            standoff(pos[2], pos[3]);
    }}
}}
'''

    def _generate_main_body(self, enclosure: Enclosure) -> str:
        """Generate the main enclosure body module."""
        has_holes = bool(enclosure.holes)
        has_vents = bool(enclosure.ventilation_zones)
        has_standoffs = bool(enclosure.standoff_positions)
        has_lid_features = enclosure.lid_type in [LidType.SNAP_FIT, LidType.SCREW_MOUNT, LidType.SLIDING]

        difference_parts = []
        if has_holes:
            difference_parts.append('        all_holes();')
        if has_vents:
            difference_parts.append('        all_vents();')
        if enclosure.lid_type == LidType.SNAP_FIT:
            difference_parts.append('        lid_grooves();')
        if enclosure.lid_type == LidType.SLIDING:
            difference_parts.append('        slide_grooves();')

        union_parts = []
        if has_standoffs:
            union_parts.append('        all_standoffs();')
        if enclosure.lid_type == LidType.SCREW_MOUNT:
            union_parts.append('        screw_bosses();')

        body_code = '''// ============================================
// MAIN BODY
// ============================================

module body() {
'''

        if difference_parts or union_parts:
            body_code += '    difference() {\n'
            body_code += '        union() {\n'
            body_code += '            hollow_box(outer_length, outer_width, outer_height, wall_thickness, bottom_thickness, corner_radius);\n'
            for part in union_parts:
                body_code += f'    {part}\n'
            body_code += '        }\n'
            for part in difference_parts:
                body_code += f'{part}\n'
            body_code += '    }\n'
        else:
            body_code += '    hollow_box(outer_length, outer_width, outer_height, wall_thickness, bottom_thickness, corner_radius);\n'

        body_code += '}'

        return body_code

    def _generate_lid(self, enclosure: Enclosure) -> str:
        """Generate the lid rendering code."""
        if enclosure.lid_type == LidType.NONE:
            return ''

        return '''// ============================================
// LID (separate for printing)
// ============================================

// Uncomment to render lid separately:
// lid();
'''

    def _generate_assembly(self, enclosure: Enclosure) -> str:
        """Generate the final assembly code."""
        lid_code = ''
        if enclosure.lid_type != LidType.NONE:
            lid_code = '''
// Lid (shown in position - comment out for printing body only)
// color("lightblue", 0.8)
//     translate([0, 0, outer_height])
//         lid();
'''

        return f'''// ============================================
// RENDER
// ============================================

// Render the body
body();
{lid_code}
// To print:
// 1. Comment out the lid() call above
// 2. Press F6 to render
// 3. Export as STL
// 4. Uncomment lid() and comment out body()
// 5. Render and export lid STL separately
'''
